## Εκφράσεις Match

Στην προηγούμενη ενότητα είδαμε την παρακάτω έκφραση `match`

```scala
count match {
  case 0 => Image.empty
  case n => aBox beside boxes(n-1)
}
```

Πώς μπορούμε να κατανοήσουμε αυτό το νέο είδος έκφρασης,
και να γράψουμε και εμείς μία δική μας?
Ας το αναλύσουμε.

Το πρώτο που πρέπει να πούμε είναι ότι η `match` είναι όντως έκφραση,
και άρα αξιολογείται με μία τιμή.
Αν ο παραπάνω ισχυρισμός δεν ίσχυε, τότε η μέθοδος `boxes` δεν θα δούλευε!

Για να καταλάβουμε πώς αξιολογείται η match, πρέπει να μάθουμε περισσότερες λεπτομέρειες.
Γενικώς, μία έκφραση `match` έχει το παρακάτω σχήμα

```scala
<anExpression> match {
  case <pattern1> => <expression1>
  case <pattern2> => <expression2>
  case <pattern3> => <expression3>
  ...
}
```

ένα`<anExpression>`, συγκεκριμένα το `count` για την παραπάνω περίπτωση, είναι μία έκφραση της οποίας η τιμή θα χρησιμοποιηθεί παρακάτω για σύγκριση.
Το `<pattern1>` και τα υπόλοιπα patterns συγκρίνονται με αυτή την τιμή.
Μέχρι τώρα έχουμε δει δύο είδη patterns:

 - μία κυριολεκτική έκφραση (όπως το `case 0`) το οποίο αντιστοιχίζεται με την ακριβή τιμή της κυριολεκτικής έκφρασης, και
 - έναν μπαλαντέρ (όπως το `case n`) το οποίο αντιστοιχίζεται με *οτιδήποτε* άλλο, και εισάγει μία σύνδεση στο δεξί μέρος της έκφρασης.

Τέλος, οι εκφράσεις που βρίσκονται στην δεξιά μεριά, όπως η `<expression1>`, είναι απλώς εκφράσεις όπως πολλές άλλες που έχουμε γράψει.
Ολόκληρη η έκφραση `match` αξιολογείται με την τιμή της δεξιάς έκφρασης του *πρώτου* pattern που μπορεί να αντιστοιχηθεί με την έκφραση προς σύγκριση.
Έτσι, όταν καλούμε το `boxes(0)` και τα δύο patterns μπορούν αντιστοιχηθούν (αφού ο μπαλαντέρ αντιστοιχίζεται με οτιδήποτε), αλλά αφού είναι πρώτο το κυριολεκτικό pattern, θα αξιολογηθεί η έκφραση `Image.empty`.

Μία έκφραση `match` που ελέγχει για όλες τις πιθανές περιπτώσεις καλείται εξαντλητική match (exhaustive match).
Αν υποθέσουμε ότι το `count` είναι πάντα ίσο ή μεγαλύτερο από το μηδέν τότε η `match` στο `boxes` είναι εξαντλητική.

Αφού εξοικειωθούμε με τις εκφράσεις `match` και πριν εξηγήσουμε την δομημένη αναδρομή πρέπει να μελετήσουμε την δομή των φυσικών αριθμών.


### Ασκήσεις {-}

#### Μαντέψτε το Αποτέλεσμα {-}

Ας ελέγξουμε το πόσο καλά κατανοούμε την match μαντεύοντας το αποτέλεσμα των παρακάτω εκφράσεων και το γιατί αξιολογούνται έτσι.

```tut:silent
"abcd" match {
  case "bcde" => 0
  case "cdef" => 1
  case "abcd" => 2
}
```

```tut:fail:silent
1 match {
  case 0 => "zero"
  case 1 => "one"
  case 1 => "two"
}
```

```tut:fail:silent
1 match {
  case n => n + 1
  case 1 => 1000
}
```

```tut:fail:silent
1 match {
  case a => a
  case b => b + 1
  case c => c * 2
}
```

<div class="solution">

Το πρώτο παράδειγμα αξιολογείται με `2`, αφού το pattern `"abcd"` είναι το μόνο που αντιστοιχίζεται με την κυριολεκτική έκφραση `"abcd"`.

Το δεύτερο παράδειγμα αξιολογείται με `"one"`, αφού αξιολογείται η πρώτη περίπτωση η οποία αντιστοιχίζεται με την έκφραση προς σύγκριση.

Το τρίτο παράδειγμα αξιολογείται με `2`, αφού το `case n` ορίζει ένα pattern μπαλαντέρ το οποίο μπορεί να αντιστοιχηθεί με οτιδήποτε.

Το τελευταίο παράδειγμα αξιολογείται με `1` αφού αξιολογείται η πρώτη περίπτωση η οποία αντιστοιχίζεται με την έκφραση προς σύγκριση.
</div>

#### Δεν Υπάρχει Αντιστοίχιση {-}

Τι γίνεται όμως αν κανένα pattern δεν μπορεί να αντιστοιχηθεί σε μία έκφραση `match`?
Μαντέψτε! Βρείτε μία έκφραση `match` η οποία απέτυχε και δείτε αν μαντέψατε σωστά.
(Σύμφωνα με αυτά που ξέρουμε ως τώρα δεν έχουμε κανέναν λόγο να περιμένουμε κάποια συγκεκριμένη συμπεριφορά οπότε οποιαδήποτε λογική υπόθεση είναι αποδεκτή.)

<div class="solution">
Παρακάτω μπορείτε να δείτε τρείς λογικές πιθανότητες που σκεφτήκαμε εμείς, αλλά ίσως εσείς σκεφτήκατε κάτι άλλο;

 - Η έκφραση θα μπορούσε να αξιολογείται με κάτι προκαθορισμένο, όπως το `Image.empty` (όμως πώς θα ήξερε η Scala τι θα ήταν αυτό;)
 - Ο μεταγλωττιστής της Scala δεν θα σας άφηνε να γράψετε τέτοιου είδους κώδικα.
 - Η έκφραση `match` θα αποτύχει κατά την διάρκεια της εκτέλεσης.

Παρακάτω μπορείτε να δείτε μία έκφραση match που θα αποτύχει.

```tut:fail:book
2 match {
  case 0 => "zero"
  case 1 => "one"
}
```

Η σωστή απάντηση είναι μία από τις δύο τελευταίες, δηλαδή είτε να εμφανιστεί αποτυχία κατά την μεταγλώττιση είτε κατά την εκτέλεση.
Στο παραπάνω παράδειγμα το πρόβλημα θα εμφανιστεί στην εκτέλεση.
Η ακριβής απάντηση εξαρτάται από το πώς είναι ρυθμισμένη η Scala (μπορούμε να πούμε στον μεταγλωττιστή να μην μεταγλωττίζει matches που δεν είναι εξαντλητικές, αλλά αυτή δεν είναι η προκαθορισμένη συμπεριφορά).
</div>
