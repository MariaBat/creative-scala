## Μία Σειρά από Κουτιά

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Ας ξεκινήσουμε με ένα παράδειγμα σχεδιασμού κουτιών σε μία γραμμή ή στήλη όπως φαίνεται στην εικόνα [@fig:recursion:sequential-boxes].

![Πέντε κουτιά χρωματισμένα με Royal Blue](./src/pages/recursion/sequential-boxes.pdf+svg){#fig:recursion:sequential-boxes}

Για αρχή, ας ορίσουμε ένα μόνο κουτί.

```tut:book
val aBox = Image.rectangle(20, 20).fillColor(Color.royalBlue)
```

Μετά, ένα κουτί σε μία γραμμή είναι απλώς

```tut:book
val oneBox = aBox
```

Αν θέλουμε να έχουμε δύο κουτιά το ένα δίπλα στο άλλο, τότε μπορούμε πολύ εύκολα να το πετύχουμε γράφοντας τον παρακάτω κώδικα.

```tut:book
val twoBoxes = aBox beside oneBox
```

Αντίστοιχα και για τρια κουτιά.

```tut:book
val threeBoxes = aBox beside twoBoxes
```

Ούτω καθεξής για όσα κουτιά θέλουμε να φτιάξουμε.

Μπορεί να σκέφτεστε ότι αυτός ο τρόπος δημιουργίας των παραπάνω εικόνων είναι κάπως ασυνήθιστος.
Για παράδειγμα γιατί να μην γράψουμε απλώς κάτι σαν το παρακάτω;

```tut:book
val threeBoxes = aBox beside aBox beside aBox
```

Αυτοί οι δύο ορισμοί είναι ίσοι μεταξύ τους.
Για κάθε νέα εικόνα που ορίσαμε, επιλέξαμε να χρησιμοποιήσουμε την προηγούμενη ώστε να δώσουμε έμφαση στην δομή. Κάπως έτσι οδηγούμαστε σιγά σιγά στην δομημένη αναδρομή.

Αυτός ο τρόπος δημιουργίας εικόνων μπορεί να γίνει πολύ κουραστικός.
Πιο βολικό θα ήταν να μπορούσαμε με κάποιον τρόπο να πούμε στον υπολογιστή πόσα κουτιά θέλουμε.
Χρησιμοποιώντας πιο τεχνικούς όρους, θα θέλαμε να εφαρμόσουμε την μέθοδο της αφαίρεσης στις παραπάνω εκφράσεις.
Σε προηγούμενο κεφάλαιο, μάθαμε ότι οι μέθοδοι χρησιμοποιούν την μέθοδο της αφαίρεσης πάνω στις εκφράσεις, οπότε ας προσπαθήσουμε και εμείς να γράψουμε μία μέθοδο ώστε να λύσουμε αυτό το πρόβλημα.

Θα ξεκινήσουμε γράφοντας τον σκελετό της μεθόδου, στον οποίο ως συνήθως θα ορίζεται το τι εισάγεται στην μέθοδο και το πώς αυτό αξιολογείται.
Σ' αυτή την περίπτωση θα δώσουμε ως είσοδο μία παράμετρο `count` τύπου `Int`, η οποία αντιπροσωπεύει τον αριθμό των κουτιών που θέλουμε και θα πάρουμε πίσω μία `Image`.

```tut:book
def boxes(count: Int): Image =
  ???
```

Τώρα ξεκινάει η εφαρμογή της νέας έννοιας, δηλαδή της *δομημένης αναδρομής*.
Παρατηρήσαμε προηγουμένως ότι το `threeBoxes` ορίζεται σε σχέση με το `twoBoxes` και το `twoBoxes` σε σχέση με το `box`.
Θα μπορούσαμε ακόμη να ορίσουμε και το `box` σε σχέση με το *κανένα* κουτί, όπως παρακάτω:

```tut:book
val oneBox = aBox beside Image.empty
```

Για να αναπαραστήσουμε το "κανένα" κουτί, χρησιμοποιήσαμε το `Image.empty`.

Φανταστείτε ότι έχουμε ήδη δημιουργήσει την μέθοδο `boxes`.
Μπορούμε να πούμε ότι οι παρακάτω ιδιότητες της `boxes` ισχύουν πάντα εφόσον είναι σωστά φτιαγμένες:

- `boxes(0) == Image.empty`
- `boxes(1) == aBox beside boxes(0)`
- `boxes(2) == aBox beside boxes(1)`
- `boxes(3) == aBox beside boxes(2)`

Οι τρεις τελευταίες ιδιότητες έχουν όλες το ίδιο βασικό σχήμα.
Μπορούμε να τις περιγράψουμε όλες, καθώς και οποιαδήποτε άλλη περίπτωση για `n > 0`, χρησιμοποιώντας μία μόνο ιδιότητα: την `boxes(n) == aBox beside boxes(n - 1)`.
Έτσι, μένουμε τελικά με τις δύο ιδιότητες:

- `boxes(0) == Image.empty`
- `boxes(n) == aBox beside boxes(n-1)`

Αυτές οι δύο, ορίζουν την συμπεριφορά της `boxes`.
Μπορούμε να δημιουργήσουμε την `boxes` μετατρέποντας αυτές τις ιδιότητες σε κώδικα.

Η `boxes` ολοκληρωμένη:

```tut:book
def boxes(count: Int): Image =
  count match {
    case 0 => Image.empty
    case n => aBox beside boxes(n-1)
  }
```

Δοκιμάστε να την εκτελέσετε και δείτε τι αποτελέσματα θα πάρετε!
Αυτός ο τρόπος είναι λίγο πιο περίπλοκος από τις ιδιότητες που γράψαμε παραπάνω, όμως είναι ακόμα η πρώτη φορά που χρησιμοποιήσαμε δομημένη αναδρομή με φυσικούς αριθμούς.

Σε αυτό το σημείο πρέπει να απαντήσουμε σε δύο ερωτήσεις.
Πρώτον, πώς δουλεύει η έκφραση `match`;
Δεύτερον, υπάρχει κάποιο γενικό μοντέλο που μπορούμε να χρησιμοποιούμε ώστε να φτιάχνουμε μόνοι μας μεθόδους σαν αυτή;
Ας απαντήσουμε στις ερωτήσεις με την σειρά.

### Άσκηση: Στοιβάζοντας Κουτιά {-}

Πριν εξηγήσουμε την έκφραση `match`, θα πρέπει να είστε σε θέση να αναδιαμορφώσετε την μέθοδο `boxes` ώστε να δημιουργήσετε την παρακάτω εικόνα [@fig:recursion:stacked-boxes].

Θέλουμε να συνηθίσουμε την σύνταξη της έκφρασης `match`, οπότε καλό θα ήταν να γράψετε τον κώδικα με το χέρι αντί να κάνετε αντιγραφή-επικόλληση.

![Τρία κουτιά, το ένα πάνω στο άλλο, γεμισμένα με χρώμα Royal Blue](./src/pages/recursion/stacked-boxes.pdf+svg){#fig:recursion:stacked-boxes}

<div class="solution">
Το μόνο που πρέπει να κάνετε είναι να αλλάξε το `beside` σε `above`.

```tut:book
def stackedBoxes(count: Int): Image =
  count match {
    case 0 => Image.empty
    case n => aBox beside stackedBoxes(n-1)
  }
```
</div>
