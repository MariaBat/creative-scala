## Μία Σειρά από Κουτιά

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Ας ξεκινήσουμε με ένα παράδειγμα σχεδιασμού κουτιών σε μία γραμμή ή στήλη όπως φαίνεται στην εικόνα [@fig:recursion:sequential-boxes].

![Έξι κουτιά γεμισμένα με Royal Blue](./src/pages/recursion/sequential-boxes.pdf+svg){#fig:recursion:sequential-boxes}

Για αρχή ας ορίσουμε ένα κουτί.

```tut:book
val aBox = Image.rectangle(20, 20).fillColor(Color.royalBlue)
```

Μετά, ένα κουτί σε μία γραμμή είναι απλώς

```tut:book
val oneBox = aBox
```

Αν θέλουμε να έχουμε δύο κουτιά το ένα δίπλα στο άλλο, τότε μπορούμε πολύ εύκολα να γράψουμε τον παρακάτω κώδικα

```tut:book
val twoBoxes = aBox beside oneBox
```

Αν θέλαμε τρία κουτιά θα γράφαμε αντίστοιχα με τα παραπάνω

```tut:book
val threeBoxes = aBox beside twoBoxes
```

Και ούτω καθεξής για όσα κουτιά θέλουμε να φτιάξουμε.

Μπορεί να σκέφτεστε ότι αυτός ο τρόπος δημιουργίας των παραπάνω εικόνων είναι κάπως περίεργος.
Για παράδειγμα γιατί να μην γράψουμε απλώς

```tut:book
val threeBoxes = aBox beside aBox beside aBox
```

Αυτοί οι δύο ορισμοί είναι ίσοι μεταξύ τους.
Για κάθε νέα εικόνα που ορίσαμε, επιλέξαμε να χρησιμοποιήσουμε την προηγούμενη ώστε να δώσουμε έμφαση στην δομή. Κάπως έτσι οδηγούμαστε σιγά σιγά στην δομημένη αναδρομή.

Αυτός ο τρόπος δημιουργίας εικόνων μπορεί να γίνει πολύ βαρετός.
Αυτό που στ'αλήθεια θα θέλαμε είναι να μπορούσαμε με κάποιον τρόπο να πούμε στον υπολογιστή πόσα κουτιά θέλουμε.
Χρησιμοποιώντας πιο τεχνικούς όρους, θα θέλαμε να εφαρμόσουμε την μέθοδο της αφαίρεσης στις παραπάνω εκφράσεις.
Μάθαμε σε προηγούμενο κεφάλαιο ότι οι μέθοδοι χρησιμοποιούν αφαίρεση πάνω στις εκφράσεις, οπότε ας προσπαθήσουμε και εμείς να γράψουμε μία μέθοδο ώστε να λύσουμε αυτό το πρόβλημα.

Θα ξεκινήσουμε γράφοντας τον σκελετό της μεθόδου, στον οποίο ως συνήθως θα ορίζεται το τι εισάγεται στην μέθοδο και το πώς αξιολογείται.
Σ'αυτή την περίπτωση θα δώσουμε ως είσοδο μία παράμετρο `count` τύπου `Int`, η οποία αντιπροσωπεύει τον αριθμό των κουτιών που θέλουμε, και θα πάρουμε πίσω μία `Image`.

```tut:book
def boxes(count: Int): Image =
  ???
```

Τώρα ξεκινάει η εφαρμογή της νέας έννοιας, δηλαδή της *δομημένης αναδρομής*.
Παρατηρήσαμε προηγουμένως ότι το `threeBoxes` ορίζεται σε σχέση με το `twoBoxes`, και το `twoBoxes` ορίζεται σε σχέση με το `box`.
Θα μπορούσαμε ακόμη και να ορίσουμε το `box` σε σχέση με το *καθόλου* κουτιά, όπως παρακάτω:

```tut:book
val oneBox = aBox beside Image.empty
```

Εδώ χρησιμοποιήσαμε το `Image.empty` ώστε να αναπαραστήσουμε το "καθόλου" κουτιά.

Φανταστείτε ότι έχουμε ήδη δημιουργήσει την μέθοδο `boxes`.
Μπορούμε να πούμε ότι οι παρακάτω ιδιότητες των `boxes` ισχύουν πάντα αν είναι σωστά φτιαγμένες (??smt is wrong??):

- `boxes(0) == Image.empty`
- `boxes(1) == aBox beside boxes(0)`
- `boxes(2) == aBox beside boxes(1)`
- `boxes(3) == aBox beside boxes(2)`

Οι τρεις τελευταίες ιδιότητες έχουν όλες το ίδιο βασικό σχήμα.
Μπορούμε να τις περιγράψουμε όλες, καθώς και οποιαδήποτε άλλη περίπτωση για `n > 0`, μόνο με την ιδιότητα `boxes(n) == aBox beside boxes(n - 1)`.
Και έτσι μείναμε με δύο μόνο ιδιότητες

- `boxes(0) == Image.empty`
- `boxes(n) == aBox beside boxes(n-1)`

Αυτές οι δύο ιδιότητες ορίζουν την συμπεριφορά του `boxes`.
Και η αλήθεια είναι ότι μπορούμε να δημιουργήσουμε το `boxes` μετατρέποντας αυτές τις ιδιότητες σε κώδικα.

Το `boxes` ολοκληρωμένο είναι όπως παρακάτω

```tut:book
def boxes(count: Int): Image =
  count match {
    case 0 => Image.empty
    case n => aBox beside boxes(n-1)
  }
```

Δοκιμάστε το και δείτε τι αποτελέσματα θα πάρετε!
Αυτός ο τρόπος είναι λίγο πιο περίπλοκος από τις ιδιότητες που γράψαμε παραπάνω αλλά είναι η πρώτη φορά που χρησιμοποιήσαμε δομημένη αναδρομή με φυσικούς αριθμούς.

Σε αυτό το σημείο πρέπει να απαντήσουμε σε δύο ερωτήσεις.
Πρώτον, πώς δουλεύει η έκφραση `match`;
Και στην συνέχεια κάτι πιο σημαντικό, υπάρχει κάποιο γενικό μοντέλο που μπορούμε να χρησιμοποιήσουμε ώστε να φτιάχνουμε μόνοι μας μεθόδους σαν αυτή;
Ας απαντήσουμε στις ερωτήσεις με την σειρά.

### Άσκηση: Στοιβάζοντας Κουτιά {-}

Ακόμη και πριν εξηγήσουμε την έκφραση `match` θα πρέπει να είστε σε θέση να αναδιαμορφώσετε την μέθοδο `boxes` ώστε να δημιουργήσετε την παρακάτω εικόνα [@fig:recursion:stacked-boxes].

Θέλουμε να συνηθίσουμε την σύνταξη της έκφρασης `match`, οπότε καλό θα ήταν να τα γράψετε όλα με το χέρι αντί να κάνετε αντιγραφή-επικόλληση.

![Τρία κουτιά το ένα πάνω στο άλλο γεμισμένα με Royal Blue](./src/pages/recursion/sequential-boxes.pdf+svg){#fig:recursion:stacked-boxes}

<div class="solution">
Το μόνο που πρέπει να κάνετε είναι να αλλάξε το `beside` σε `above`.

```tut:book
def stackedBoxes(count: Int): Image =
  count match {
    case 0 => Image.empty
    case n => aBox beside stackedBoxes(n-1)
  }
```
</div>
