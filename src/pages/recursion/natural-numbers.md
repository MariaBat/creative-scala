## Οι Φυσικοί Αριθμοί

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
val aBox = Image.rectangle(20, 20).fillColor(Color.royalBlue)
```

Οι φυσικοί αριθμοί είναι οι ακέραιοι, μεγαλύτεροι ή ίσοι με το μηδέν. Με άλλα λόγια είναι οι αριθμοί 0, 1, 2, 3, ... (Μερικοί ορίζουν τους φυσικούς αριθμούς σαν να ξεκινάν από το 1 και όχι από το 0. Στην δική μας περίπτωση δεν έχει πολύ μεγάλη σημασία ποιόν ορισμό προτιμάτε αλλά εμείς θα υποθέσουμε ότι ξεκινάν από το 0.)

Μία ενδιαφέρουσα ιδιότητα των φυσικών αριθμών είναι ότι μπορούν να οριστούν αναδρομικά. Αυτό σημαίνει ότι μπορούμε να τους ορίσουμε σε σχέση με τον εαυτό τους. Θα μπορούσε κανείς να σκεφτεί ότι αυτός ο κυκλικός ορισμός θα οδηγούσε σε παραλογισμό. Για να αποφευχθεί κάτι τέτοιο χρησιμοποιούμε μία *βασική περίπτωση (base case)* η οποία σταματάει την αναδρομή. Επομένως, ο ορισμός είναι ο εξής:

Ένας φυσικός αριθμός `n` είναι

- 0, ή
- 1 + `m`, όπου `m` είναι ένας φυσικός αριθμός.

Η περίπτωση 0 είναι η βασική περίπτωση, ενώ η επόμενη περίπτωση είναι αναδρομική αφού ορίζει τον φυσικό αριθμό `n` σε σχέση με τον φυσικό αριθμό `m`. Επειδή ο `m` είναι πάντα μικρότερος από τον `n`, και η βασική υπόθεση είναι είναι ο μικρότερος πιθανός φυσικός αριθμός, αυτός ο ορισμός ορίζει όλους τους φυσικούς αριθμούς.

Εάν μας δοθεί ένας φυσικός αριθμός, για παράδειγμα ο 3, μπορούμε να τον διασπάσουμε χρησιμοποιώντας τον παραπάνω ορισμό, ως εξής:

3 = 1 + 2 = 1 + (1 + 1) = 1 + (1 + (1 + 0))

Χρησιμοποιούμε τον κανόνα της αναδρομής ώστε να απλοποιήσουμε την εξίσωση μέχρι να φτάσουμε σε σημείο που δεν μπορούμε να χρησιμοποιήσουμε πιά τον κανόνα. Μετά χρησιμοποιούμε την βασική περίπτωση ώστε να σταματήσουμε την αναδρομή.


## Δομημένη Αναδρομή

Τώρα είμαστε έτοιμοι να δούμε την δομημένη αναδρομή. Η μορφή της δομημένης αναδρομής για φυσικούς αριθμούς μας δίνει δύο πράγματα:

- έναν σκελετό κώδικα για την επεξεργασία οποιουδήποτε φυσικού αριθμού που μπορούμε να χρησιμοποιήσουμε σε πάρα πολλές περιπτώσεις, και
- εγγύηση ότι μπορούμε να χρησιμοποιήσουμε αυτόν τον σκελετό για *οποιονδήποτε* υπολογισμό με φυσικούς αριθμούς.

Θυμηθείτε ότι προηγουμένως γράψαμε την `boxes` όπως παρακάτω

```tut:book
def boxes(count: Int): Image =
  count match {
    case 0 => Image.empty
    case n => aBox beside boxes(n-1)
  }
```

Όταν φτιάχναμε την `boxes` πέσαμε πάνω σ'αυτή τη μορφή που προαναφέραμε.
Μπορούμε εύκολα να δούμε ότι η παραπάνω μορφή ακολουθεί τον ορισμό των φυσικών αριθμών.
Θυμηθείτε τον αναδρομικό ορισμό των φυσικών αριθμών: ένας φυσικός αριθμός `n` είναι

- 0, ή
- 1 + `m`, όπου `m` είναι ένας φυσικός αριθμός.

Η μορφή της έκφρασης `match` ταιριάζει ακριβώς μ'αυτόν τον ορισμό. Η παρακάτω έκφραση

```scala
count match {
  case 0 => ???
  case n => ???
}
```

σημαίνει ότι ελέγχουμε το `count` για δύο περιπτώσεις, την περίπτωση όπου το `count` είναι 0, και την περίπτωση όπου το `count` είναι οποιοσδήποτε άλλος φυσικός αριθμός `n` (που είναι `1 + m`).

Η δεξιά μεριά της έκφρασης `match` μας λέει τι κάνουμε σε κάθε περίπτωση. Στην περίπτωση μηδέν αντιστοιχεί το αποτέλεσμα `Image.empty`. Στην περίπτωση `n` αντιστοιχεί το `aBox beside boxes(n-1)`.

Και τώρα θα μπούμε στο πιό σημαντικό κομμάτι.
Παρατηρήστε οτι η δομή της δεξιάς μεριάς αντικατοπτρίζει την δομή των φυσικών αριθμών που προσπαθούμε να αντιστοιχίσουμε.
Όταν αντιστοιχίζουμε την βασική περίπτωση 0, το αποτέλεσμα είναι η βασική περίπτωση `Image.empty`. Όταν αντιστοιχίζουμε την αναδρομική περίπτωση `n` η δομή της δεξιάς μεριάς ταιριάζει με την δομή της αναδρομικής περίπτωσης του ορισμού των φυσικών αριθμών.
Στον ορισμό δηλώνεται ότι το `n` είναι `1 + m`.
Στην δεξιά μεριά αντικαθιστούμε το 1 με το `aBox`, το + με το `beside`, και καλούμε αναδρομικά την `boxes` με το `m` (που είναι `n-1`) όπου σύμφωνα με τον ορισμό γίνεται η αναδρομή.

```tut:book
def boxes(count: Int): Image =
  count match {
    case 0 => Image.empty
    case n => aBox beside boxes(n-1)
  }
```

Για να συνοψίσουμε, η αριστερή μεριά της έκφρασης `match` ταιριάζει ακριβώς με τον ορισμό των φυσικών αριθμών. Η δεξιά μεριά ταιριάζει με τον ορισμό αλλά αντικαταστήσαμε τους φυσικούς αριθμούς με εικόνες. Η εικόνα που είναι ισοδύναμη με το μηδέν είναι η `Image.empty`. Η εικόνα που είναι ισοδύναμη με το `1 + m` είναι η `aBox beside boxes(m)`.

Αυτή η γενική μορφή ισχύει για οτιδήποτε θέλουμε να γράψουμε που μετατρέπει τους φυσικούς αριθμούς σε κάποιον άλλο τύπο.
Πάντα έχουμε μία έκφραση `match`.
Πάντα έχουμε τις δύο μορφές, μία για την βασική και μία για την αναδρομική περίπτωση.
Οι εκφράσεις της δεξιάς μεριάς είναι πάντα η βασική περίπτωση και η αναδρομική η οποία περιέχει κάτι που αντικαθιστά το `1` και το `+`, και μία αναδρομική κλήση για το `n-1`.

<div class="callout callout-info">
#### Δομημένη Αναδρομη στη Δομή των Φυσικών Αριθμών{-}

Παρακάτω μπορείτε να δείτε την γενική μορφή της δομημένης αναδρομής σε φυσικούς αριθμούς

```scala
def name(count: Int): Result =
  count match {
    case 0 => resultBase
    case n => resultUnit add name(n-1)
  }
```

όπου τα `Result`, `resultBase`, `resultUnit`, καθώς και το `add`, είναι συγκεκριμένα για το πρόβλημα που επιλύουμε.
Έτσι, για να εφαρμόσουμε την δομημένη αναδρομή σε φυσικούς αριθμούς πρέπει να

 - να αναγνωρίσουμε ότι η μέθοδος που γράφουμε παίρνει ως είσοδο έναν φυσικό αριθμό,
 - να βρούμε τον τύπο του αποτελέσματος, και
 - να αποφασίσουμε ποια πρέπει να είναι η βασική περίπτωση, η μονάδα και η πρόσθεση για το αποτέλεσμα.
</div>

Τώρα είμαστε έτοιμοι να διασκεδάσουμε εξερευνώντας αυτό το βασικό αλλά πολύ δυνατό εργαλείο.

<div class="callout callout-info">
### Αποδείξεις και Προγράμματα

Αν έχετε μελετήσει μαθηματικά το πιό πιθανό είναι ότι έχετε συναντήσει την μέθοδο της επαγωγής σε αποδείξεις.
Η γενική μορφή για απόδειξη μέσω επαγωγής μοιάζει πολύ με την γενική μορφή της δομημένης αναδρομής σε φυσικούς αριθμούς.
Αυτό δεν είναι σύμπτωση, υπάρχει μία σχέση μεταξύ αυτών των δύο.
Μπορούμε να δούμε την δομημένη αναδρομή σε φυσικούς αριθμούς ως μία απόδειξη μέσω επαγωγής.
Η δυνατότητα χρήσης της ιδιότητας της μετατροπής των φυσικών αριθμών σε σχέση με τον σκελετό της δομημένης αναδρομής, βασίζεται πάνω σε μαθηματικά που χρησιμοποιούμε έμμεσα.
Ακόμη, μπορούμε να αποδείξουμε ιδιότητες του κώδικά μας χρησιμοποιώντας την σύνδεση αυτών των δύο: οποιαδήποτε δομημένη αναδρομή ορίζει εμμέσως μία απόδειξη κάποιας ιδιότητας.

Αυτή η γενική σύνδεση μεταξύ αποδείξεων και προγραμμάτων είναι γνωστή ως *Ισομορφισμός Howard-Curry*.
</div>

### Ασκήσεις {-}

#### Σταυρός {-}

Η πρώτη άσκηση που θα κάνουμε είναι να φτιάξουμε μία μέθοδο με όνομα `cross` που θα δημιουργεί εικόνες σταυρών. Στην εικόνα [@fig:recursion:cross] φαίνονται τέσσερις σταυροί, οι οποίοι αντιστοιχούν στην κλήση της μεθόδου `cross` από το `0` ως το `3`.

Ο σκελετός της μεθόδου είναι ο παρακάτω

```tut:book
def cross(count: Int): Image =
  ???
```

![Οι σταυροί παράγονται με `count` από το 0 ως το 3.](./src/pages/recursion/cross.pdf+svg){#fig:recursion:cross}

Ποια μορφή θα χρησιμοποιήσουμε για να γεμίσουμε το σώμα της `cross`? Γράψτε εσείς την μορφή.

<div class="solution">
Θα χρησιμοποιήσουμε δομημένη αναδρομή σε φυσικούς αριθμούς. Αυτό που γράψατε θα πρέπει να μοιάζει με το παρακάτω

```scala
def cross(count: Int): Image =
  count match {
    case 0 => <resultBase>
    case n => <resultUnit> <add> cross(n-1)
  }
```
</div>

Τώρα που βρήκαμε ποια μορφή θα χρησιμοποιήσουμε πρέπει να συμπληρώσουμε τα επιμέρους κομμάτια του προβλήματος:

 - την βασική περίπτωση, και
 - τους operators της μονάδας και της πρόσθεσης.

Βοήθεια: χρησιμοποιήστε την εικόνα [@fig:recursion:cross] για να αναγνωρίσετε τα παραπάνω ζητούμενα στοιχεία.

<div class="solution">
Από την εικόνα μπορούμε να καταλάβουμε ότι η βασική περίπτωση είναι ένας κύκλος.

Διαδοχικά στοιχεία στην εικόνα προσθέτουν κύκλους πάνω, κάτω, στα δεξιά και στα αριστερά. Άρα η μονάδα είναι ίδια με την βασική περίπτωση, δηλαδή ένας κύκλος, αλλά ο operator της πρόσθεσης δεν είναι ένα απλό `beside` ή ένα `above` όπως είχαμε δει προηγουμένως. Σ'αυτή την περίπτωση είναι `unit beside (unit above cross(n-1) above unit) beside unit`.
</div>

Τώρα συμπληρώστε όλα τα στοιχεία της μεθόδου `cross`.

<div class="solution">
Παρακάτω μπορείτε να δείτε την δική μας λύση.

```scala
def cross(count: Int): Image = {
  val unit = Image.circle(20)
  count match {
    case 0 => unit
    case n => unit beside (unit above cross(n-1) above unit) beside unit
  }
}
```
</div>


#### Σκακιέρα {-}

Στην άσκηση με τον σταυρό είδαμε οτι το δύσκολο κομμάτι είναι το να αναγνωρίσουμε την αναδρομική δομή σε σχέση μ'αυτό που προσπαθούμε να δημιουργήσουμε. Μόλις όμως το καταφέραμε, η συμπλήρωση των υπόλοιπων στοιχείων της μορφής της δομημένης αναδρομής ήταν εύκολη.

Σ'αυτή και στην επόμενη άσκηση θα προσπαθήσουμε να εξασκήσουμε το μάτι σας στην δομημένη αναδρομή.
Η αποστολή σας σ'αυτήν την άσκηση είναι να αναγνωρίσετε πως μπορεί να χρησιμοποιηθεί η  δομημένη αναδρομή σε μία σκακιέρα και να φτιάξετε μία μέθοδο που σχεδιάζει σκακιέρες.
Ο σκελετός της μεθόδου δεν είναι όπως ο παρακάτω

```tut:silent:book
def chessboard(count: Int): Image =
  ???
```

Στην εικόνα [@fig:recursion:chessboards] μπορείτε να δείτε παραδείγματα με σκακιέρες που έχουν σχεδιαστεί με το `count` να ξεκινάει από το `0` και να φτάνει μέχρι το `2`.
Βοήθεια: παρατηρήστε ότι το `count` αυτή τη φορά δεν μας δίνει το πλάτος της σκακιέρας αλλά μας λέει τον αριθμό των "μονάδων σκακιέρας"  που πρέπει να συνδυάσουμε.

![Σκακιέρες που παράγονται για `count` από 0 ως 2.](./src/pages/recursion/chessboards.pdf+svg){#fig:recursion:chessboards}

Φτιάξτε την μέθοδο `chessboard`.

<div class="solution">
η `chessboard` είναι μία δομημένη αναδρομή σε φυσικούς αριθμούς, οπότε μπορούμε να γράψουμε απευθείας τον σκελετό της μεθόδου.

```scala
def chessboard(count: Int): Image =
  count match {
    case 0 => resultBase
    case n => resultUnit add cross(n-1)
  }
```

Όπως και προηγουμένως, πρέπει να αποφασίσουμε πως θα είναι η βασική περίπτωση, η μονάδα και η πρόσθεση για το αποτέλεσμα.
Σας δώσαμε μία βοήθεια δείχνοντας σας την εξέλιξη της σκακιέρας στην εικόνα [@fig:recursion:chessboards].
Από αυτό μπορούμε να καταλάβουμε ότι η βασική περίπτωση είναι μία σκακιέρα 2 επί 2.

```tut:silent:book
val blackSquare = Image.rectangle(30, 30) fillColor Color.black
val redSquare   = Image.rectangle(30, 30) fillColor Color.red

val base =
  (redSquare beside blackSquare) above (blackSquare beside redSquare)
```

Τώρα πρέπει να βρούμε την μονάδα και την πρόσθεση.
Εδώ βλέπουμε κάτι διαφορετικό από τα προηγούμενα παραδείγματα.
Η μονάδα είναι η τιμή που παίρνουμε από την αναδρομική κλήση `chessboard(n-1)`.
Η λειτουργία της πρόσθεσης είναι `(unit beside unit) above (unit beside unit)`.

Βάζοντάς τα όλα μαζί παίρνουμε τον παρακάτω κώδικα

```tut:silent:book
def chessboard(count: Int): Image = {
  val blackSquare = Image.rectangle(30, 30) fillColor Color.black
  val redSquare   = Image.rectangle(30, 30) fillColor Color.red
  
  val base =
    (redSquare   beside blackSquare) above (blackSquare beside redSquare)
  count match {
    case 0 => base
    case n =>
      val unit = chessboard(n-1)
      (unit beside unit) above (unit beside unit)
  }
}
```

Αν έχετε προηγούμενη εμπειρία στον προγραμματισμό ίσως σκεφτήκατε ότι μπορείτε να φτιάξετε μία σκακιέρα χρησιμοποιώντας δύο εμφωλευμένους βρόγχους.
Εδώ εμείς ακολουθήσαμε μία διαφορετική προσέγγιση ορίζοντας μία μεγάλη σκακιέρα ως σύνθεση μικρότερων.
Η κατανόηση αυτής της διαφορετικής προσέγγισης για αποσύνθεση προβλημάτων είναι ένα βήμα κλειδί για να γίνετε ικανοί στον συναρτησιακό προγραμματισμό.
</div>


#### Τρίγωνο Sierpinkski {-}

Το τρίγωνο Sierpinski, όπως φαίνεται στην εικόνα [@fig:recursion:sierpinski], είναι ένα διάσημο fractal. (Στην πραγματικότητα, η εικόνα [@fig:recursion:sierpinski] δείχνει ένα τρίγωνο Sier*pink*ski.)

![Το τρίγωνο Sierpinski.](./src/pages/recursion/sierpinski.pdf+svg){#fig:recursion:sierpinski}

Μπορεί να φαίνεται αρκετά περίπλοκο αλλά μπορούμε να διασπάσουμε την δομή σε μία μορφή την οποία μπορούμε να φτιάξουμε χρησιμοποιώντας δομημένη αναδρομή σε φυσικούς αριθμούς.
Φτιάξτε μία μέθοδο με τον παρακάτω σκελετό

```tut:book
def sierpinski(count: Int): Image =
  ???
```

Αυτή τη φορά δεν θα σας δοθεί βοήθεια.
Έχουμε ήδη δει όλα όσα χρειαζόμαστε για να το λύσουμε.

<div class="solution">
Το βήμα κλειδί είναι να αναγνωρίσουμε ότι η βασική μονάδα του τριγώνου Sierpinski είναι η `triangle above (triangle beside triangle)`.
Μόλις κατανοήσουμε το παραπάνω τότε συνεχίζοντας θα δούμε ότι ο κώδικας έχει ακριβώς την ίδια δομή με την `chessboard`.
Παρακάτω μπορείτε να δείτε έναν τρόπο λύσης.

```tut:book

def sierpinski(count: Int): Image = {
  val triangle = Image.triangle(10, 10) lineColor Color.magenta
  count match {
    case 0 => triangle above (triangle beside triangle)
    case n =>
      val unit = sierpinski(n-1)
      unit above (unit beside unit)
  }
}
```

</div>
