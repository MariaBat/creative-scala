## Εξερευνώντας την Random

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Μέχρι τώρα έχουμε δει μόνο τα βασικά για την χρήση της `Random`. Σ' αυτή την ενότητα θα δούμε περισσότερα χαρακτηριστικά της και θα τα χρησιμοποιήσουμε για να δημιουργήσουμε πιο ενδιαφέρουσες εικόνες.

<div class="callout callout-info">
Εκτός από τα imports που εισάγουμε συνήθως, σ' αυτή την ενότητα θα προσθέσουμε και τα παρακάτω:

```tut:silent
import doodle.random._
```
</div>

### Κανονικές Κατανομές

Πολύ συχνά όταν χρησιμοποιούμε τυχαίους αριθμούς στην αναπαραγωγική τέχνη επιλέγουμε συγκεκριμένες κατανομές λόγω των σχημάτων που παρέχουν.
Για παράδειγμα, η εικόνα [@fig:generative:distributions] δείχνει χίλια τυχαία σημεία που έχουν παραχθεί χρησιμοποιώντας μία ομοιόμορφη κατανομή, μία κανονική κατανομή (ή Γκαουσιανή) και μία κανονική κατανομή στο τετράγωνο.

![Σημεία που έχουν τοποθετηθεί σύμφωνα με ομοιόμορφη κατανομή, κανονική κατανομή και κανονική κατανομή στο τετράγωνο.](./src/pages/generative/distributions.pdf+svg){#fig:generative:distributions}

Όπως μπορείτε να δείτε, η κανονική κατανομή παράγει περισσότερα σημεία προς το κέντρο από ότι η ομοιόμορφη κατανομή.

ΤΟ Doodle παρέχει δύο μεθόδους για δημιουργία κανονικά κατανεμημένων αριθμών, με τις οποίες μπορούμε να δημιουργήσουμε και πολλές άλλες κατανομές.
Η κανονική κατανομή ορίζεται από δύο παραμέτρους, την *μέση τιμή* (mean), η οποία ορίζει το κέντρο της κατανομής και την *τυπική απόκλιση* (standard deviation), η οποία ορίζει το εύρος της κατανομής.
Οι αντίστοιχες μέθοδοι στο Doodle είναι οι παρακάτω

- η `Random.normal`, που παράγει έναν `Double` από μία κανονική κατανομή με μέση τιμή 0 και τυπική απόκλιση 1.0 και
- η `Random.normal(mean, stdDev)`, που παράγει έναν `Double` από μία κανονική κατανομή με την μέση τιμή και τυπική απόκλιση που της δίνονται.


### Δομημένη Τυχαιότητα

Απο πολύ δομημένες εικόνες περάσαμε σε πολύ τυχαίες εικόνες.
Θα ήταν ωραία αν μπορούσαμε να βρούμε μία μέση λύση που να περιλαμβάνει στοιχεία τυχαιότητας αλλά και δομής.
Μπορούμε να χρησιμοποιήσουμε την `flatMap` για να το πετύχουμε---με τη `flatMap` μπορούμε να χρησιμοποιήσουμε μία τυχαία παραγόμενη τιμή ώστε να δημιουργήσουμε μία άλλη τυχαία τιμή.
Έτσι δημιουργείται μία εξάρτηση μεταξύ των τιμών---η προηγούμενη τυχαία τιμή επηρεάζει την επόμενη τυχαία τιμή που θα παραχθεί.

Για παράδειγμα, μπορούμε να φτιάξουμε μία μέθοδο η οποία με δεδομένο ένα χρώμα θα αλλάζει τυχαία την απόχρωσή του.

```tut:silent:book
def nextColor(color: Color): Random[Color] = {
  val spin = Random.normal(15.0, 10.0)
  spin map { s => color.spin(s.degrees) }
}
```

Χρησιμοποιώντας την `nextColor`, μπορούμε να φτιάξουμε μία σειρά κουτιών με διαβάθμιση χρωμάτων που θα είναι και τυχαία αλλά και δομημένη: το κάθε επόμενο χρώμα της διαβάθμισης είναι μία διαφοροποίηση του προηγούμενου.

```tut:silent:book
def coloredRectangle(color: Color, size: Int): Image =
  rectangle(size, size).
    lineWidth(5.0).
    lineColor(color.spin(30.degrees)).
    fillColor(color)

def randomGradientBoxes(count: Int, color: Color): Random[Image] =
  count match {
    case 0 => Random.always(Image.empty)
    case n =>
      val box = coloredRectangle(color, 20)
      val boxes = nextColor(color) flatMap { c => randomGradientBoxes(n-1, c) }
      boxes map { b => box beside b }
  }
```

Ένα παράδειγμα εξόδου μπορείτε να δείτε στην εικόνα [@fig:generative:structured-gradient-boxes].

![Κουτιά γεμισμένα με διαβαθμίσεις χρωμάτων που είναι μερικώς τυχαίες.](./src/pages/generative/structured-gradient-boxes.pdf+svg){#fig:generative:structured-gradient-boxes}

### Ασκήσεις {-}

#### Συστήματα Σωματιδίων {-}

Ένα *σύστημα σωματιδίων* είναι μία τεχνική που χρησιμοποιείται στα γραφικά υπολογιστών ώστε να δημιουργηθεί μεγάλος αριθμός "σωματιδίων" που κινούνται σύμφωνα με απλούς κανόνες.
Στην εικόνα [@fig:generative:smoke] μπορείτε να δείτε ένα παράδειγμα ενός συστήματος σωματιδίων που προσομοιώνει μία φωτιά και καπνό.
Γι' αυτούς που τους αρέσουν τα μαθηματικά, ένα σύστημα σωματιδίων είναι βασικά μία *στοχαστική διαδικασία* ή ένας *τυχαίος περίπατος (random walk)*.

![Μία προσομοίωση φωτιά με καπνό που δημιουργήθηκε με την χρήση ενός συστήματος σωματιδίων.](src/pages/generative/smoke.pdf+svg){#fig:generative:smoke}

Σ' αυτή την άσκηση θα χτίσουμε ένα σύστημα σωματιδίων που θα σας δώσει ένα ευέλικτο σύστημα για να πειραματιστείτε μ' αυτού του είδους τις ιδέες.
Θα ξεκινήσουμε με ένα κλασικό σύστημα και μετά θα το αλλάξουμε έτσι ώστε να δημιουργήσουμε επαναχρησιμοποιήσιμα κομμάτια.

Παρακάτω μπορείτε να δείτε πώς δουλεύει ένα σύστημα σωματιδίων.
Για να ζωγραφίσουμε ένα μεμονωμένο σωματίδιο πρέπει

- να επιλέξουμε μία αρχική θέση,
- να αποφασίσουμε για πόσα χρονικά βήματα θέλουμε να κινήσουμε το σύστημα σωματιδίων και
- σε κάθε χρονικό βήμα, η νέα θέση του σωματιδίου να είναι ίση με την θέση του προηγούμενου βήματος συν κάποιον τυχαίο θόρυβο (και πιθανόν και κάποια μη-τυχαία (ντετερμινιστική) κίνηση, όπως για παράδειγμα ταχύτητα ή επιτάχυνση).

Ένα σύστημα σωματιδίων είναι απλώς μία συλλογή σωματιδίων---στην εικόνα [@fig:generative:smoke] μπορείτε να δείτε 20 σωματίδια μετά από 20 βήματα.

Στην παραπάνω περιγραφή, σπάσαμε σε μικρά κομμάτια τα στοιχεία που αποτελούν ένα σύστημα σωματιδίων.
Τώρα το μόνο που έχουμε να κάνουμε είναι να τα υλοποιήσουμε.

Η αρχική θέση μπορεί να είναι ένα οποιοδήποτε `Random[Point]` (τυχαίο σημείο).
Δημιουργήστε ένα τώρα.

<div class="solution">
Το παρακάτω θα κάνει αυτό που θέλουμε.
Αν θέλετε, μπορείτε να δημιουργήσετε μία πιο περίπλοκη (και ενδιαφέρουσα) κατανομή στην αρχική θέση.

```tut:silent:book
val start = Random.always(Point.zero)
```
</div>

Ας φτιάξουμε μία μέθοδο με όνομα `step`, η οποία θα κάνει ένα βήμα στο σύστημα σωματιδίων.
Ο σκελετός της θα είναι ο παρακάτω

```tut:silent:book
def step(current: Point): Random[Point] =
  ???
```

Πρέπει να αποφασίσουμε πώς θα αλλάξουμε το σημείο στο οποίο βρισκόμαστε τώρα (`current` point) ώστε να δημιουργείται το επόμενο σημείο.
Προτείνουμε την πρόσθεση τυχαίου θορύβου και μία σταθερά που θα ονομάζεται "drift" και μ' αυτόν τον τρόπο θα εξασφαλιστεί η κίνηση των σημείων προς μία συγκεκριμένη κατεύθυνση.
Για παράδειγμα, μπορούμε να αυξήσουμε την συντεταγμένη `x` κατά10 μονάδες και έτσι θα προκληθεί η κλίση των σωματιδίων προς την δεξιά μεριά της οθόνης καθώς και κάποιος θόρυβος, κανονικά κατανεμημένος, στις συντεταγμένες `x` και `y`.

<div class="solution">
Επιλέξαμε την χρήση κανονικά κατανεμημένου θορύβου που είναι ίδιος και στις δύο κατευθύνσεις.
Μία αλλαγή στον θόρυβο θα άλλαζε και το σχήμα του αποτελέσματος---αξίζει να "παίξετε" με διάφορες ρυθμίσεις.

```tut:silent:book
def step(current: Point): Random[Point] = {
  val drift = Point(current.x + 10, current.y)
  val noise = 
    Random.normal(0.0, 5.0) flatMap { x =>
      Random.normal(0.0, 5.0) map { y =>
        Vec(x, y)
      }
    }
    
  noise.map(vec => drift + vec)
}
```
</div>

Τώρα που μπορούμε να δώσουμε ένα βήμα (`step`) σ' ενα σωματίδιο, πρέπει να συνδέσουμε μία σειρά βημάτων ώστε να πάρουμε έναν "περίπατο" (`walk`).
Υπάρχει κάτι που πρέπει να προσέξουμε εδώ: θέλουμε να ζωγραφίσουμε και τα ενδιάμεσα στάδια, οπότε θα ορίσουμε δύο μεθόδους:

- μία μέθοδο για μετασχηματισμό ενός σημείου σε εικόνα και
- μία μέθοδο με όνομα `walk` που παράγει μία `Random[Image]` (τυχαία εικόνα)

Οι σκελετοί τους είναι οι παρακάτω

```tut:silent:book
def render(point: Point): Image =
  ???
  
def walk(steps: Int): Random[Image] =
  ???
```

Η υλοποίηση της μεθόδου `render` μπορεί να γίνει με όποιον τρόπο θέλετε.
Για την υλοποίηση της `walk`, θα πρέπει να καλέσετε την `step` ώστε να πάρετε το επόμενο `Point` (σημείο) και μετά να καλέσετε την `render` ώστε να μετατρέψετε το σημείο σε κάτι που μπορεί να σχεδιαστεί.
Θα πρέπει επίσης να έχετε έναν συσσωρευτή για την εικόνα που έχει δημιουργηθεί μέχρι τώρα.
Βοήθεια: μπορεί να σας φανεί χρήσιμος ο ορισμός μίας βοηθητικής παραμέτρου για την `walk`.

<div class="solution">
Στον ορισμό μας για την `render`, δείξαμε πώς μπορούμε να χρησιμοποιήσουμε πληροφορίες από το σημείο ώστε να αλλάξουμε το σχήμα με ενδιαφέρον τρόπο.

Ο ορισμός της `walk` είναι μία δομημένη αναδρομή σε φυσικούς αριθμούς με έναν εσωτερικό συσσωρευτή και με αναδρομή στην `flatMap`.

```tut:silent:book
def render(point: Point): Image = {
  val length = (point - Point.zero).length
  val sides = (length / 20).toInt + 3
  val hue = (length / 200).turns
  val color = Color.hsl(hue, 0.7.normalized, 0.5.normalized)
  Image.
    star(sides, 5, 3, 0.degrees).
    noFill.
    lineColor(color).
    at(point.toVec)
}

def walk(steps: Int): Random[Image] = {
  def loop(count: Int, current: Point, image: Image): Random[Image] = {
    count match {
      case 0 => Random.always(image on render(current))
      case n =>
        val next = step(current)
        next flatMap { pt =>
          loop(count - 1, pt, image on render(current))
        }
    }
  }
 
  start flatMap { pt => loop(steps, pt, Image.empty) }
}
```
</div>

Τώρα θα πρέπει να μπορείτε να καλέσετε την `walk` ώστε να πάρετε κάποιο αποτέλεσμα.

Το τελικό βήμα είναι η δημιουργία σωματιδίων και η χρήση τους.
Δημιουργήστε μία μέθοδο με όνομα `particleSystem`, με τον παρακάτω σκελετό

```tut:silent:book
def particleSystem(particles: Int, steps: Int): Random[Image] =
  ???
```

ο οποίος είναι κατάλληλος γι' αυτό που θέλουμε να κάνουμε.

<div class="solution">
Για άλλη μία φορά έχουμε δομημένη αναδρομή σε φυσικούς αριθμούς.
Αντίθετα από την `walk`, η αναδρομή γίνεται στην `map` και όχι στην `flatMap`.
Αυτό γίνεται επειδή η `particleSystem` δεν προσθέτει νέες τυχαίες επιλογές.

```tut:silent:book
def particleSystem(particles: Int, steps: Int): Random[Image] = {
  particles match {
    case 0 => Random.always(Image.empty)
    case n => walk(steps) flatMap { img1 => 
      particleSystem(n-1, steps) map { img2 => 
        img1 on img2
      }
    }
  }
}
```
</div>

Τώρα δείτε το αποτέλεσμα και "πειράξτε το" μέχρι να φτιάξετε κάτι που σας αρέσει.
Εμείς δεν είμαστε πολύ ευχαριστημένοι με το αποτέλεσμα του κώδικά μας.
Τα αστέρια είναι πολύ κοντά μεταξύ τους και τα χρώματα δεν είναι πολύ ενδιαφέροντα.
Για ένα πιο ενδιαφέρον αποτέλεσμα θα μπορούσαμε να προσθέσουμε λίγο περισσότερο θόρυβο, να αλλάξουμε το αρχικό χρώμα και να μειώσουμε το φάσμα των χρωμάτων.

#### Τυχαίες Αλλαγές {-}

Η υλοποίηση της `particleSystem` που είδαμε παραπάνω είναι εφαρμογή για μία συγκεκριμένη επιλογή συστήματος σωματιδίων.
Για να κάνουμε πιο εύκολο τον πειραματισμό θα μπορούσαμε να κάνουμε κάποιες αλλαγές πάνω στις επιλογές της `walk` και της `start`.
Πώς πιστεύετε ότι μπορούμε να το κάνουμε αυτό;

<div class="solution">
Θα μπορούσαμε να κάνουμε τις `walk` `start` και `render`, παραμέτρους της `particleSystem`, και τις `start` και `render` παραμέτρους της `walk`.
</div>

Φτιάξτε το.

<div class="solution">
Αν προσθέσουμε παραμέτρους με σωστά ονόματα και τύπους, οι αλλαγές στον κώδικα θα είναι οι ελάχιστες.
Είναι σαν να κάνουμε το αντίθετο της αντικατάστασης---βγάζουμε ολόκληρες αναπαραστάσεις από τον κωδικά μας και τις αντικαθιστούμε με παραμέτρους μεθόδων

```tut:silent:book
def walk(
  steps: Int, 
  start: Random[Point],
  render: Point => Image
): Random[Image] = {
  def loop(count: Int, current: Point, image: Image): Random[Image] = {
    count match {
      case 0 => Random.always(image on render(current))
      case n =>
        val next = step(current)
        next flatMap { pt =>
          loop(count - 1, pt, image on render(current))
        }
    }
  }
 
  start flatMap { pt => loop(steps, pt, Image.empty) }
}

def particleSystem(
  particles: Int, 
  steps: Int,
  start: Random[Point],
  render: Point => Image,
  walk: (Int, Random[Point], Point => Image) => Random[Image]
): Random[Image] = {
  particles match {
    case 0 => Random.always(Image.empty)
    case n => walk(steps, start, render) flatMap { img1 => 
      particleSystem(n-1, steps, start, render, walk) map { img2 => 
        img1 on img2
      }
    }
  }
}
```
</div>

Αυτός ο κώδικας δεν είναι ικανοποιητικός.
Οι περισσότερες παράμετροι της `particleSystem` πρέπει να περαστούν μόνο στην `walk`.
Αυτές οι παράμετροι δεν αλλάζουν μέσα στην δομημένη αναδρομή στο σώμα της `particleSystem`.
Σ' αυτό σημείο μπορούμε να εφαρμόσουμε την μέθοδο της αντικατάστασης---μπορούμε να αντικαταστήσουμε μία κλήση μεθόδου με την τιμή με την οποία αξιολογείται---και να αφαιρέσουμε την `walk` και τις σχετικές παραμέτρους από την `particleSystem`.

```tut:silent:book
def particleSystem(particles: Int, walk: Random[Image]): Random[Image] = {
  particles match {
    case 0 => Random.always(Image.empty)
    case n => walk flatMap { img1 => 
      particleSystem(n-1, walk) map { img2 => 
        img1 on img2
      }
    }
  }
}
```

Αν έχετε συνηθίσει να προγραμματίζετε με προστακτικό (διαδικαστικό) προγραμματισμό τότε ίσως η παραπάνω τεχνική σας φανεί πολύ διαφορετική στον τρόπο σκέψης.
Θυμηθείτε ότι κάναμε μεγάλη προσπάθεια για να σιγουρευτούμε ότι η χρήση τυχαίων αριθμών δεν θα ενοχλήσει τον θεσμό της αντικατάστασης μέχρι την στιγμή που καλείται η `run`.
Η μέθοδος `walk`, στην πραγματικότητα δεν δημιουργεί έναν τυχαίο περίπατο.
Αντιθέτως, περιγράφει την δημιουργία ενός τυχαίου περιπάτου καθώς εκτελείται ο κώδικάς της.
Αυτός ο χωρισμός μεταξύ περιγραφής και πράξης σημαίνει ότι μπορεί να χρησιμοποιηθεί αντικατάσταση.
Η περιγραφή της υλοποίησης ενός τυχαίου περιπάτου μπορεί να χρησιμοποιηθεί για την δημιουργία πολλών και διαφορετικών τυχαίων περιπάτων.
