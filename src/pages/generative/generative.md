## Αναπαραγωγική Τέχνη

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Αναπαραγωγική τέχνη είναι αυτή της οποίας κάποιο μέρος της σύνθεσής της οφείλεται σε μια αυτόνομη διαδικασία. Συνεπώς, για εμάς αυτό σημαίνει ότι θα πρέπει να προσθέσουμε ένα στοιχείο τυχαιότητας.

Ας δούμε ένα πολύ απλό παράδειγμα. Μάθαμε προηγουμένως πως να φτιάχνουμε ομόκεντρους κύκλους.

```tut:silent:book
def concentricCircles(n: Int): Image =
  n match {
    case 0 => circle(10)
    case n => concentricCircles(n-1) on circle(n * 10) 
  }
```

(Πλέον ξέρουμε ότι θα μπορούσαμε να έχουμε χρησιμοποιήσει την `Range` και κάποια μέθοδο όπως η `allOn`.)

Μάθαμε επίσης πως μπορούμε να φτιάξουμε χρωματιστούς κύκλους χρησιμοποιώντας μια δεύτερη παράμετρο.

```tut:silent:book
def concentricCircles(n: Int, color: Color): Image =
  n match {
    case 0 => circle(10) fillColor color
    case n => concentricCircles(n-1, color.spin(15.degrees)) on (circle(n * 10) fillColor color) 
  }
```

Οι εικόνες που έχουν κατασκευαστεί με τον παραπάνω τρόπο είναι ωραίες αλλά και κάπως βαρετές αφού είναι τόσο συνηθισμένες. Τι θα γίνονταν αν θέλαμε να κάνουμε μια τυχαία αλλαγή στην απόχρωση του χρώματος σε κάθε βήμα;

Η Scala μας παρέχει μερικές μεθόδους για παραγωγή *τυχαίων αριθμών*. Μια τέτοια μέθοδος είναι η `math.random`. Κάθε φορά που την καλούμε, λαμβάνουμε μια διαφορετική τιμή τύπου `Double` ανάμεσα στο 0.0 και το 1.0[^ψευδο-τυχαίοι].

[^ψευδο-τυχαίοι]: Οι ψευδο-τυχαίοι αριθμοί δεν είναι πραγματικά τυχαίοι. Το αποτέλεσμα καθορίζεται από μια τιμή που ονομάζεται *seed* (σπόρος). Αν ξέρουμε την τιμή της seed μπορούμε να προβλέψουμε τα αποτελέσματα που θα πάρουμε από την κλήση της `math.random` με απόλυτη ακρίβεια. Όμως, αν το προσπαθήσουμε από την αντίθετη μεριά---δηλαδή να προβλέψουμε το seed έχοντας μια σειρά αποτελεσμάτων---είναι πολύ δύσκολο. Οι αριθμοί που παράγονται μ'αυτόν τον τρόπο καλούνται *ψευδο-τυχαίοι αριθμοί*, επειδή δεν είναι πραγματικά τυχαίοι αλλά παρόλα αυτά, είναι πολύ δύσκολο να προβλεφθούν.

```tut:book
math.random
math.random
```

Έχοντας ως δεδομένο την `math.random`, θα μπορούσαμε να φτιάξουμε μια μέθοδο που θα επιστρέφει μια τυχαία `Angle` όπως παρακάτω.

```tut:book
def randomAngle: Angle = 
  math.random.turns
  
randomAngle
randomAngle
```

Γιατί να μην θέλουμε να το λύσουμε έτσι; Ποια βασική αρχή καταργείται;

<div class="solution">
Η παραγωγή τυχαίων αριθμών με αυτόν το τρόπο απειλεί την έννοια της αντικατάστασης. Όπως θυμάστε από προηγούμενο κεφάλαιο, η μέθοδος της αντικατάστασης έλεγε ότι όπου βλέπουμε μια έκφραση θα πρέπει να μπορούμε να αντικαταστήσουμε την τιμή με την οποία αξιολογείται, χωρίς να αλλάξουμε το νόημα του προγράμματος. Επομένως, αυτό σημαίνει ότι οι παρακάτω κώδικες

```tut:book
val result1 = randomAngle
val result2 = randomAngle
```

και

```tut:book
val result1 = randomAngle
val result2 = result1
```

θα έπρεπε να είναι το ίδιο πρόγραμμα, κάτι που φανερά δεν ισχύει.
</div>

Τι μπορούμε να κάνουμε; Να υποφέρουμε από τις σφεντόνες και τα βέλη αυτών των ανόητων υπολογιστικών μοντέλων ή να παλέψουμε μέσα σε μια θάλασσα από "παρενέργειες" και τελικά να νικήσουμε; Η επιλογή είναι βασικά μία.
