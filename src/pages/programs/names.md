## Ονόματα

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Στην προηγούμενη ενότητα είδαμε πολλές καινούριες έννοιες.
Σε αυτήν, θα εξερευνήσουμε μία: τα ονόματα τιμών.

Χρησιμοποιούμε ονόματα για να αναφερθούμε σε πράγματα.
Για παράδειγμα, το όνομα "Professeur Emile Perrot" αναφέρεται σε μία ποικιλία μυρωδικών τριανταφύλλων, ενώ τα "Cherry Parfait" είναι ανθεκτικά σε ασθένειες αλλά δεν έχουν σχεδόν καθόλου άρωμα.
Η συζήτηση για το πώς ακριβώς λειτουργεί αυτή η σχέση ονόματος και έννοιας στον προφορικό λόγο είναι πολύ μεγάλη.
Οι γλώσσες προγραμματισμού είναι πολύ πιο περιορισμένες, κάτι που μας επιτρέπει να είμαστε πιο ακριβής: τα ονόματα αναφέρονται σε τιμές.
Μερικές φορές θα λέμε ότι κάποια ονόματα είναι *συνδεμένα* με τιμές ή ότι ένα όνομα εισάγει μία *σύνδεση*.
Από δω και πέρα, αντί να γράφουμε μία τιμή, μπορούμε να χρησιμοποιούμε το όνομά της, αν της έχει αποδοθεί κάποιο.
Με άλλα λόγια, ένα όνομα αξιολογείται ως η τιμή στην οποία αναφέρεται.
Έτσι, γεννιέται το εξής ερώτημα: πώς δίνουμε ονόματα στις τιμές;
Υπάρχουν πολλοί τρόποι για να γίνει αυτό στη Scala.
Ας δούμε μερικούς.


### Κυριολεκτικές Εκφράσεις Αντικειμένων

Έχουμε ήδη δεί ένα παράδειγμα δήλωσης κυριολεκτικής έκφρασης αντικειμένου.

```tut:silent:book
object Example {
  (circle(100) fillColor Color.paleGoldenrod lineColor Color.indianRed).draw
}
```

Η παραπάνω είναι μία κυριολεκτική έκφραση, όπως άλλες που έχουμε δει, αλλά σε αυτή την περίπτωση δημιουργεί ένα αντικείμενο με το όνομα `Example`.
Όταν χρησιμοποιούμε το όνομα `Example` σε ένα πρόγραμμα, αυτό αξιολογείται όπως το αντικείμενο στο οποίο αντιστοιχεί.

```scala
Example
// Example.type = Example$@76c39258
```

Δοκιμάστε το μερικές φορές στην κονσόλα.
Βλέπετε κάποια διαφορά;
Ίσως παρατηρήσατε ότι την *πρώτη* φορά που χρησιμοποιήσατε το όνομα `Example` δημιουργήθηκε μία εικόνα αλλά τις επόμενες φορές δεν έγινε το ίδιο.
Την πρώτη φορά που χρησιμοποιούμε το όνομα ενός αντικειμένου, αυτό αξιολογείται και δημιουργείται.
Στις επόμενες χρήσεις του ονόματος, το αντικείμενο υπάρχει ήδη και δεν αξιολογείται ξανά.
Μπορούμε να καταλάβουμε ότι αυτή η περίπτωση είναι διαφορετική αφού η έκφραση μέσα στο αντικείμενο καλεί την μέθοδο `draw`.
Αν την αντικαταστήσουμε με κάτι όπως το `1 + 1` (ή απλώς αφαιρέσουμε την κλήση της `draw`) δεν θα μπορέσουμε να καταλάβουμε την διαφορά.
Θα πούμε περισσότερα γι'αυτό σε επόμενο κεφάλαιο.

Ίσως αναρωτιέστε ποιός είναι ο τύπος του αντικειμένου που μόλις δημιουργήσαμε.
Μπορούμε να ρωτήσουμε την κονσόλα.

```scala
:type Example
// Example.type
```

Ο τύπος του `Example` είναι ο `Example.type`, ένας μοναδικός τύπος που καμία άλλη τιμή δεν έχει τον ίδιο.


### Δηλώσεις `val`

Η δήλωση μίας κυριολεκτικής έκφρασης αντικειμένου συνδυάζει την δημιουργία αντικειμένου και τον ορισμό ονόματος.
Αν είχαμε την δυνατότητα να τα χωρίσουμε, θα μας ήταν χρήσιμο αφού έτσι θα μπορούσαμε να δώσουμε όνομα σε κάποιο προ-υπάρχον αντικείμενο.
Οι δηλώσεις `val`, μας δίνουν αυτήν ακριβώς την δυνατότητα.

Χρησιμοποιούμε το `val` γράφοντας

```scala
val <name> = <value>
```

και αντικαθιστώντας το `<name>` και το `<value>` με το όνομα και την αντίστοιχη τιμή με την οποία αξιολογείται.
Για παράδειγμα

```tut:silent:book
val one = 1
val anImage = Image.circle(100).fillColor(Color.red)
```

Αυτές οι δύο δηλώσεις ορίζουν τα ονόματα `one` και `anImage`.
Μπορούμε να χρησιμοποιήσουμε αυτά τα ονόματα για να αναφερθούμε σ' αυτές τις τιμές αργότερα στον κώδικά μας.

```tut:book
one
anImage
```


### Δηλώσεις

Παραπάνω μιλήσαμε για δηλώσεις και ορισμούς.
Τώρα θα δούμε τι ακριβώς σημαίνουν αυτοί οι όροι και θα αναλύσουμε σε βάθος τις διαφορές μεταξύ `object` και `val`.

Έχουμε ήδη μιλήσει για εκφράσεις.
Είναι ένα μέρος του προγράμματος που αξιολογείται με κάποια τιμή.
Μία *δήλωση* ή ένας *ορισμός* είναι ένα άλλο μέρος του προγράμματος αλλά δεν αξιολογείται με κάποια τιμή.
Αντί γι'αυτό, οι δηλώσεις δίνουν ένα όνομα σε κάτι---όχι πάντα σε κάποια τιμή, αφού στη Scala, μπορείτε να δηλώσετε και τύπους. Εμείς σ' αυτό το βιβλίο δεν θα αφιερώσουμε πολύ χρόνο σ' αυτό.
Τα `object` και `val` είναι δηλώσεις.

Μία συνέπεια του διαχωρισμού των δηλώσεων από τις εκφράσεις, είναι ότι δεν μπορούμε να γράψουμε προγράμματα όπως το παρακάτω:

```tut:fail:book
val one = ( val aNumber = 1 )
```

αφού το `val aNumber = 1` δεν είναι έκφραση και άρα δεν αξιολογείται με κάποια τιμή.

Παρόλα αυτά, μπορούμε να γράψουμε:

```tut:book
val aNumber = 1
val one = aNumber
```


### Το Top-Level

Το να έχουμε και `object` και `val` δηλώσεις, δεν είναι καθόλου ικανοποιητικό αφού και τα δύο δίνουν ονόματα σε τιμές.
Γιατί να μην έχουμε μόνο την `val` για δήλωση ονομάτων και το `object` μόνο για να δημιουργεί αντικείμενα χωρίς να τα ονομάζει;
Μπορείτε να δηλώσετε μία κυριολεκτική έκφραση αντικειμένου χωρίς όνομα;

<div class="solution">
Όχι, η Scala δεν μας το επιτρέπει.
Για παράδειγμα, δεν μπορούμε να γράψουμε:

```tut:fail:book
object {}
```

Πρέπει να δίνουμε όνοματα σε όλες τις κυριολεκτικές εκφράσεις αντικειμένων που δημιουργούμε.
</div>

Η Scala κάνει μία διάκριση μεταξύ αυτού που αποκαλείται *top-level* κώδικας και του υπόλοιπου.
Ο κώδικας στο top-level είναι αυτός που δεν περικλύεται από άλλο κώδικα.
Με άλλα λόγια είναι κάτι που μπορούμε να γράψουμε μέσα σε ένα αρχείο και η Scala μπορεί να το μεταγλωττίσει χωρίς να το βάλει μέσα σε `αντικείμενο`.

Έχουμε δει ότι οι εκφράσεις δεν επιτρέπονται στο top-level.
Ούτε και οι ορισμοί `val`.
Όμως, οι κυριολεκτικές εκφράσεις αντικειμένων επιτρέπονται.

Αυτή η διάκριση είναι λίγο ενοχλητική.
Υπάρχουν γλώσσες που δεν τον έχουν αυτόν τον περιορισμό.
Η Scala τον έχει επειδή βασίζεται στο Java Virtual Machine (JVM), το οποίο σχεδιάστηκε για να εκτελεί κώδικα Java.
Η Java είναι μια από τις γλώσσες που κάνουν την διάκριση μεταξύ top-level κώδικα και του υπόλοιπου και έτσι η Scala είναι υποχρεωμένη να κάνει και αυτή το ίδιο ώστε να μπορεί να δουλέψει με το JVM.
Η κονσόλα της Scala *δεν* κάνει αυτή τη διάκριση με τον top-level κώδικα (για παράδειγμα ότι γράψαμε στην κονσόλα, δεν βρίσκονταν μέσα σε κάποιο αντικείμενο) κάτι που μπορεί να οδηγήσει σε σύγχυση όταν ξεκινάμε την χρήση της.

Αν μία κυριοκλεκτική έκφραση αντικειμένου επιτραπεί στο top-level αλλά ένας ορισμός `val` όχι, τότε μπορούμε να δηλώσουμε μία `val` μέσα σε μία κυριολεκτική έκφραση αντικειμένου;
Αν μπορούμε να δηλώσουμε μία `val` μέσα σε μία κυριολεκτική έκφραση αντικειμένου, τότε μπορούμε αργότερα να αναφερθούμε σ' αυτό το όνομα;

<div class="solution">
Φυσικά και μπορούμε!

Μπορούμε να τοποθετήσουμε μία `val` μέσα σε μία κυριολεκτική έκφραση αντικειμένου όπως παρακάτω:

```tut:silent:book
object Example {
  val hi = "Hi!"
}
```

Μπορούμε μετά να αναφερθούμε σε αυτό χρησιμοποιώντας την σύνταξη με την τελεία `.` που έχουμε ήδη δει επανειλημμένως.

```tut:book
Example.hi
```

Παρατηρήστε ότι δεν μπορούμε να χρησιμοποιήσουμε το `hi` μόνο του

```tut:fail:book
hi
```

Πρέπει να πούμε στην Scala ότι θέλουμε να αναφερθούμε στο όνομα `hi` που έχει οριστεί μέσα στο αντικείμενο `Example`.
</div>


### Εμβέλεια

Εάν κάνατε την τελευταία άσκηση (και ελπίζουμε πώς την κάνατε!!) θα είδατε ότι ένα όνομα δηλωμένο μέσα σε ένα αντικείμενο δεν μπορεί να χρησιμοποιηθεί έξω από αυτό χωρίς αναφορά στο αντικείμενο μέσα στο οποίο βρίσκεται.
Συγκεκριμένα, αν δηλώσουμε:

```tut:book
object Example {
  val hi = "Hi!"
}
```

δεν μπορούμε να γράψουμε

```tut:fail:book
hi
```

Πρέπει να πούμε στην Scala να ψάξει το `hi` μέσα στο `Example`.

```tut:book
Example.hi
```

Λέμε ότι ένα όνομα είναι *ορατό* εκεί όπου μπορεί να χρησιμοποιηθεί χωρίς περισσότερες πληροφορίες και ονομάζουμε *εμβέλεια* αυτού του ονόματος, τα μέρη στα οποία είναι ορατό.
Έτσι χρησιμοποιώντας την νέα αυτή φανταχτερή ορολογία, το `hi` δεν είναι ορατό εκτός του `Example` ή αλλιώς το `hi` δεν είναι σε εμβέλεια εκτός του `Example`.

Πώς βρίσκουμε την εμβέλεια ενός ονόματος;
Ο κανόνας είναι αρκετά απλός: ένα όνομα είναι ορατό από το σημείο της δήλωσής του μέχρι το τέλος των κοντινότερων αγκύλων (οι αγκύλες είναι η `{` και η `}`).
Στο παραπάνω παράδειγμα, το `hi` βρίσκεται μέσα στις αγκύλες του `Example` και άρα εκεί είναι ορατό.
Δεν είναι ορατό πουθενά αλλού.

Μπορούμε να δηλώσουμε κυριολεκτικές εκφράσεις αντικειμένων μέσα σε κυριολεκτικές εκφράσεις αντικειμένων, κάτι που μας επιτρέπει να παρατηρήσουμε καλύτερα τις εμβέλειες.
Για παράδειγμα στον παρακάτω κώδικα

```tut:silent:book
object Example1 {
  val hi = "Hi!"

  object Example2 {
    val hello = "Hello!"
  }
}
```

το `hi` είναι σε εμβέλεια στο `Example2` (το `Example2` ορίζεται μέσα στις αγκύλες που περικλείουν το `hi`).
Όμως η εμβέλεια του `hello` περιορίζεται στο `Example2` και άρα έχει μικρότερη εμβέλεια από το `hi`.

Τι θα συμβεί αν δηλώσουμε ένα όνομα μέσα στην εμβέλεια στην οποία έχει ήδη δηλωθεί;
Αυτό είναι γνωστό ως *shadowing (επισκίαση)*.
Στον παρακάτω κώδικα, ο ορισμός του `hi` μέσα στο `Example2` επισκιάζει τον ορισμό του `hi` στο `Example1`

```tut:silent:book
object Example1 {
  val hi = "Hi!"

  object Example2 {
    val hi = "Hello!"
  }
}
```

Η Scala μας το επιτρέπει αλλά η χρήση του είναι γενικώς κακή ιδέα αφού μπορεί πολύ εύκολα να μας μπερδέψει.

Δεν χρειάζεται να χρησιμοποιήσουμε κυριολεκτικές εκφράσεις αντικειμένων για να δημιουργήσουμε νέες εμβέλειες.
Η Scala μας επιτρέπει να δημιουργήσουμε μία νέα εμβέλεια οπουδήποτε χρησιμοποιώντας απλώς αγκύλες.
Έτσι μπορούμε να γράψουμε:

```tut:silent:book
object Example {
  val good = "Good"
  
  // Δημιουργία νέας εμβέλειας
  {
    val morning = good ++ " morning" 
    val toYou = morning ++ " to you"
  }
  
  val day = good ++ " day, sir!"
}
```

το `morning` (και το `toYou`) είναι δηλωμένα μέσα σε μία νέα εμβέλεια. Δεν υπάρχει τρόπος να αναφερθούμε σ' αυτήν την εμβέλεια από έξω (δεν έχει όνομα) άρα δεν μπορούμε να αναφερθούμε στο `morning` εκτός της εμβέλειας μέσα στην οποία είναι δηλωμένο.
Αν είχαμε μυστικά που δεν θέλαμε να τα μάθει το υπόλοιπο πρόγραμμα, αυτός θα ήταν ένας πολύ καλός τρόπος να τα κρύψουμε.

Ο τρόπος με τον οποίο λειτουργούν οι εμφωλευμένες εμβέλειες στην Scala καλείται *lexical scoping*.
Το lexical scoping δεν υπάρχει σε όλες τις γλώσσες.
Για παράδειγμα, η Ruby και η Python δεν το έχουν, ενώ η Javascript το απέκτησε πρόσφατα.
Η γνώμη των συγγραφέων είναι ότι η δημιουργία γλώσσας χωρίς lexical scoping είναι σαν να τρως ένα ματσάκι πιπεριών Γουατεμάλας και μετά να πηγαίνεις στην τουαλέτα χωρίς να πλύνεις τα χέρια σου.


### Ασκήσεις {-}

Δοκιμάστε το πόσο καλά κατανοήσατε τα ονόματα και τις εμβέλειες βρίσκοντας την τιμή του `answer` σε κάθε μία από τις παρακάτω περιπτώσεις.

```tut:silent:book
val a = 1
val b = 2
val answer = a + b
```

<div class="solution">
Ένα απλό παράδειγμα για να ξεκινήσετε. Το `answer` είναι `1 + 2`, δηλαδή `3`.
</div>

```tut:silent:book
object One {
  val a = 1

  object Two {
    val a = 3
    val b = 2
  }

  object Answer {
    val answer = a + Two.b
  }
}
```

<div class="solution">
Ακόμα ένα απλό παράδειγμα. Το `answer` είναι `1 + 2`, δηλαδή `3`. Η εμβέλεια του `Two.a` δεν φτάνει μέχρι εκεί που είναι ορισμένο το `answer`.
</div>

```tut:silent:book
object One {
  val a = 5
  val b = 2
  
  object Answer {
    val a = 1
    val answer = a + b
  }
}
```

<div class="solution">
Εδώ το `Answer.a` επισκιάζει το `One.a` άρα το `answer` είναι `1 + 2`, δηλαδή `3`.
</div>

```tut:silent:book
object One {
  val a = 1
  val b = a + 1
  val answer = a + b
}
```

<div class="solution">
Αυτό είναι μία χαρά. Η έκφραση `a + 1` στην δεξιά μεριά της δήλωσης του `b` είναι μία έκφραση όπως όλες τις άλλες άρα το `answer` είναι και πάλι `3`.
</div>

```tut:silent:book
object One {
  val a = 1
  
  object Two {
    val b = 2
  }
  
  val answer = a + b
}
```

<div class="solution">
Αυτός ο κώδικας δεν θα μεταγλωττιστεί αφού η εμβέλεια του `b` δεν φτάνει μέχρι εκεί που έχει οριστεί το `answer`.
</div>

```tut:fail:silent:book
object One {
  val a = b - 1
  val b = a + 1
  
  val answer = a + b
}
```

<div class="solution">
Ερώτηση παγίδα! Αυτός ο κώδικας δεν δουλεύει. Εδώ τα `a` και `b` είναι ορισμένα έτσι ώστε να έχουν σχέση μεταξύ τους κατι που όδηγεί σε φαύλο κύκλο.
</div>

