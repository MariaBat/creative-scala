## Ονόματα

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Στην προηγούμενη ενότητα παρουσιάσαμε πολλές καινούριες έννοιες.
Σε αυτή την ενότητα θα τις εξερευνήσουμε: ονόματα τιμών.

Χρησιμοποιούμε ονόματα για να αναφερθούμε σε πράγματα.
Για παράδειγμα, το "Professeur Emile Perrot" αναφέρεται σε μια ποικιλία πολύ μυρωδικών (??μυρωδάτων/ευωδιαστών??) τριαντάφυλλων, ενώ το "Cherry Parfait" είναι μια ποικιλία ανθεκτική σε ασθένειες αλλά που δεν μυρίζει σχεδόν καθόλου.
Πολύ μελάνι έχει χυθεί, και πολλά πηγούνια έχουν ξυστεί, για το πώς ακριβώς λειτουργεί αυτή η σχέση στον προφορικό λόγο.
Οι γλώσσες προγραμματισμού είναι πολύ περισσότερο περιορισμένες, κάτι που μας επιτρέπει να είμαστε πιο ακριβής: τα ονόματα αναφέρονται σε τιμές.
Μερικές φορές θα λέμε ότι κάποια ονόματα είναι *δεσμευμένα* για τιμές, ή ότι ένα όνομα εισάγει μια *δέσμευση*.
Όποτε θα γράφαμε μια τιμή, μπορούμε από δω και πέρα να χρησιμοποιούμε το όνομά της, αν έχει κάποιο.
Με άλλα λόγια, ένα όνομα αξιολογείται όπως η τιμή στην οποία αναφέρεται.
Έτσι, γεννιέται το ερώτημα: πώς δίνουμε ονόματα στις τιμές;
Υπάρχουν πολλοί τρόποι για να γίνει αυτό στη Scala.
Ας δούμε μερικούς.


### Κυριολεκτικά Αντικειμένων

Έχουμε ήδη δεί παραδείγματα δήλωσης κυριολεκτικού αντικειμένου.

```tut:silent:book
object Example {
  (circle(100) fillColor Color.paleGoldenrod lineColor Color.indianRed).draw
}
```

Αυτό είναι μια κυριολεκτική έκφραση, όπως άλλα κυριολεκτικά που έχουμε δει μέχρι τώρα, αλλά σε αυτή την περίπτωση δημιουργείται ένα αντικείμενο με το όνομα `Example`.
Όταν χρησιμοποιούμε το όνομα `Example` σε ένα πρόγραμμα, αυτό αξιολογείται όπως το αντικείμενο στο οποίο αντιστοιχεί.

```scala
Example
// Example.type = Example$@76c39258
```

Δοκιμάστε το μερικές φορές στην κονσόλα.
Παρατηρείτε κάποια διαφορά στις χρήσεις του ονόματος;
Ίσως παρατηρήσατε ότι την *πρώτη* φορά που χρησιμοποιήσατε το όνομα `Example` δημιουργήθηκε μια εικόνα, αλλά τις επόμενες φορές δεν έγινε το ίδιο.
Την πρώτη φορά που χρησιμοποιούμε το όνομα ενός αντικειμένου, αξιολογείται το σώμα (??ο όγκος??) του και δημιουργείται το αντικείμενο.
Στις επόμενες χρήσεις του ονόματος, το αντικείμενο υπάρχει ήδη και δεν αξιολογείται ξανά.
Μπορούμε να καταλάβουμε ότι υπάρχει μια διαφορά σ'αυτή την περίπτωση αφού η έκφραση μέσα στο αντικείμενο καλεί την μέθοδο `draw`.
Αν την αντικαθιστούσαμε με κάτι όπως το `1 + 1` (ή απλώς αφαιρούσαμε την κλήση της `draw`) δεν θα μπορούσαμε να καταλάβουμε την διαφορά.
Θα πούμε πολλά περισσότερα γι'αυτό σε επόμενο κεφάλαιο.

Ίσως αναρωτιέστε για τον τύπο του αντικειμένου που μόλις δημιουργήσαμε.
Μπορούμε να ρωτήσουμε την κονσόλα γι'αυτό.

```scala
:type Example
// Example.type
```

Ο τύπος του `Example` είναι ο `Example.type`, ένας μοναδικός τύπος που καμία άλλη τιμή δεν έχει ίδιο.


### Δηλώσεις `val`

Η δήλωση ενός κυριολεκτικού αντικειμένου συνδυάζει την δημιουργία αντικειμένου και τον ορισμό ονόματος.
Αν μπορούσαμε να τα χωρίσουμε, θα ήταν χρήσιμο ώστε να μπορούμε να δώσουμε όνομα σε κάποιο αντικείμενο που προ-υπήρχε.
Μια δήλωση `val` μας επιτρέπει να κάνουμε ακριβώς αυτό.

Χρησιμοποιούμε το `val` γράφοντας

```scala
val <name> = <value>
```

αντικαθιστώντας το `<name>` και το `<value>` με το όνομα και την αντίστοιχη τιμή με την οποία αξιολογείται.
Για παράδειγμα

```tut:silent:book
val one = 1
val anImage = Image.circle(100).fillColor(Color.red)
```

Αυτές οι δύο δηλώσεις ορίζουν τα ονόματα `one` και `anImage`.
Παρακάτω στον κώδικά μας μπορούμε να χρησιμοποιήσουμε αυτά τα ονόματα για να αναφερθούμε σε τιμές.

```tut:book
one
anImage
```


### Δηλώσεις

Παραπάνω μιλήσαμε για δηλώσεις και ορισμούς.
Ήρθε η ώρα να γίνουμε πιο συγκεκριμένοι στο τι σημαίνουν αυτοί οι όροι, και να δούμε σε βάθος τις διαφορές μεταξύ `object` και `val`.

Ξέρουμε ήδη για εκφράσεις.
Είναι ένα μέρος του προγράμματος που αξιολογείται με κάποια τιμή.
Μια *δήλωση* ή ένας *ορισμός* είναι ένα άλλο μέρος του προγράμματος , αλλά δεν αξιολογείται σε κάποια τιμή.
Αντί γι'αυτό, δίνουν ένα όνομα σε κάτι---όχι πάντα σε κάποια τιμή αφού στη Scala μπορείτε να δηλώσετε και τύπους, αλλά δεν θα αφιερώσουμε πολύ χρόνο σ'αυτό.
Το `object` αλλά και το `val` είναι δηλώσεις.

Μια συνέπεια του διαχωρισμού των δηλώσεων από τις εκφράσεις είναι ότι δεν μπορούμε να γράψουμε προγράμματα όπως το παρακάτω

```tut:fail:book
val one = ( val aNumber = 1 )
```

αφού το `val aNumber = 1` δεν είναι έκφραση και άρα δεν αξιολογείται με κάποια τιμή.

Παρόλα αυτά μπορούμε να γράψουμε

```tut:book
val aNumber = 1
val one = aNumber
```


### Το Top-Level (Πάνω-Επίπεδο)

Το να έχουμε και `object` και `val` δηλώσεις, δεν είναι καθόλου ικανοποιητικό αφού και τα δύο δίνουν ονόματα σε τιμές.
Γιατί να μην έχουμε την `val` μόνο για δήλωση ονομάτων, και το `object` μόνο για να δημιουργεί αντικείμενα χωρίς να τα ονομάζει;
Μπορείτε να δηλώσετε ένα κυριολεκτικό αντικειμένου χωρίς όνομα;

<div class="solution">
Όχι, η Scala δεν μας το επιτρέπει.
Για παράδειγμα, μπορούμε να γράψουμε

```tut:fail:book
object {}
```

Πρέπει να δίνουμε όνομα σε ότι κυριολεκτικό αντικειμένου δημιουργούμε.
</div>

Η Scala κάνει μία διάκριση μεταξύ του *top-level* κώδικα και του υπόλοιπου κώδικα.
Ο κώδικας στο top-level είναι αυτός που δεν είναι περιτυλιγμένος από άλλο κώδικα.
Με άλλα λόγια είναι κάτι που μπορούμε να γράψουμε σε ένα αρχείο και η Scala να το μεταγλωττίσει χωρίς να πρέπει να το βάλει μέσα σε ένα `αντικείμενο`.

Έχουμε δει ότι οι εκφράσεις δεν επιτρέπονται στο top-level.
Ούτε και οι ορισμοί `val`.
Τα κυριολεκτικά αντικειμένων όμως, επιτρέπονται.

Αυτή η διάκριση είναι λίγο ενοχλητική.
Άλλες γλώσσες δεν τον έχουν αυτόν τον περιορισμό.
Αυτό συμβαίνει στην Scala επειδή βασίζεται πάνω στην Java Virtual Machine (JVM), η οποία σχεδιάστηκε για να εκτελεί κώδικα Java.
Η Java κάνει μία διάκριση μεταξύ του top-level κώδικα και του υπόλοιπου, και έτσι η Scala είναι υποχρεωμένη να κάνει και αυτή το ίδιο ώστε να δουλέψει με την JVM.
Η κονσόλα της Scala *δεν* κάνει αυτή τη διάκριση με τον top-level κώδικα (μπορούμε να σκεφτούμε οτιδήποτε ήταν γραμμένο στην κονσόλα και δεν βρίσκονταν μέσα σε κάποιο αντικείμενο) κάτι που μπορεί να οδηγήσει σε σύγχυση όταν ξεκινάμε αρχικά την χρήση της Scala.

Αν ένα κυριολεκτικό αντικειμένου επιτραπεί στο the top-level, αλλά ένας ορισμός `val` όχι, σημαίνει ότι μπορούμε να δηλώσουμε ένα `val` μέσα σ'ένα κυριολεκτικό αντικειμένου;
Αν μπορούμε να δηλώσουμε ένα `val` μέσα σ'ένα κυριολεκτικό αντικειμένου, μπορούμε αργότερα να αναφερθούμε σ'αυτό το όνομα;

<div class="solution">
Φυσικά και μπορούμε!

Μπορούμε να τοποθετήσουμε ένα `val` μέσα σε ένα κυριολεκτικό αντικειμένου όπως παρακάτω:

```tut:silent:book
object Example {
  val hi = "Hi!"
}
```

Μπορούμε μετά να αναφερθούμε σε αυτό χρησιμοποιώντας το συντακτικό `.` που έχουμε ήδη χρησιμοποιήσει.

```tut:book
Example.hi
```

Παρατηρήστε ότι δεν μπορούμε να χρησιμοποιήσουμε το `hi` μόνο του

```tut:fail:book
hi
```

Πρέπει να πούμε στην Scala ότι θέλουμε να αναφερθούμε στο όνομα `hi` που έχει οριστεί μέσα στο αντικείμενο `Example`.
</div>


### Εμβέλεια

Εάν κάνατε την τελευταία άσκηση (και την κάνατε, δεν την κάνατε;) θα είδατε ότι ένα όνομα δηλωμένο μέσα σε ένα αντικείμενο δεν μπορεί να χρησιμοποιηθεί έξω από αυτό χωρίς αναφορά στο αντικείμενο μέσα στο οποίο βρίσκεται το όνομα.
Συγκεκριμένα, αν δηλώσουμε

```tut:book
object Example {
  val hi = "Hi!"
}
```

δεν μπορούμε να γράψουμε

```tut:fail:book
hi
```

Πρέπει να πούμε στην Scala να ψάξει το `hi` μέσα στο `Example`.

```tut:book
Example.hi
```

Λέμε ότι ένα όνομα είναι *ορατό* στις θέσεις που μπορεί να χρησιμοποιηθεί χωρίς ;άλλες εξηγήσεις,  και ονομάζουμε *εμβέλεια* τα μέρη στα οποία είναι ορατό.
Έτσι χρησιμοποιώντας την νέα αυτή φανταχτερή ορολογία, το `hi` δεν είναι ορατό εκτός του `Example`, ή εναλλακτικά το `hi` δεν είναι σε εμβέλεια εκτός του `Example`.

Πώς βρίσκουμε την εμβέλεια ενός ονόματος;
Ο κανόνας είναι αρκετά απλός: ένα όνομα είναι ορατό από το σημείο της δήλωσής του μέχρι το τέλος των κοντινότερων αγκύλων (οι αγκύλες είναι η `{` και η `}`).
Στο παραπάνω παράδειγμα, το `hi` βρίσκεται μέσα στις αγκύλες του `Example` και άρα εκεί είναι ορατό.
Δεν είναι ορατό πουθενά αλλού.

Μπορούμε να δηλώσουμε κυριολεκτικά αντικειμένων μέσα σε κυριολεκτικά αντικειμένων, κάτι που μας επιτρέπει να ξεχωρίζουμε πιο εύκολα την εμβέλεια.
Για παράδειγμα στον παρακάτω κώδικα

```tut:silent:book
object Example1 {
  val hi = "Hi!"

  object Example2 {
    val hello = "Hello!"
  }
}
```

το `hi` είναι σε εμβέλεια στο `Example2` (το `Example2` ορίζεται μέσα στις αγκύλες που περικλείουν το `hi`).
Όμως η εμβέλεια του `hello` περιορίζεται στο `Example2`, και άρα έχει μικρότερη εμβέλεια από το `hi`.

Τι θα συμβεί αν δηλώσουμε ένα όνομα μέσα στην εμβέλεια στην οποία έχει ήδη δηλωθεί;
Αυτό είναι γνωστό ως *shadowing (επισκίαση)*.
Στον παρακάτω κώδικα, ο ορισμός του `hi` μέσα στο `Example2` επισκιάζει τον ορισμό του `hi` στο `Example1`

```tut:silent:book
object Example1 {
  val hi = "Hi!"

  object Example2 {
    val hi = "Hello!"
  }
}
```

Η Scala μας το επιτρέπει αλλά είναι γενικώς μια κακή ιδέα αφού κάνει τον κώδικα πιο μπερδεμένο.

Δεν χρειάζεται να χρησιμοποιήσουμε κυριολεκτικά αντικειμένων για να δημιουργήσουμε νέες εμβέλειες.
Η Scala μας επιτρέπει να δημιουργήσουμε μια νέα εμβέλεια οπουδήποτε εισάγοντας απλώς αγκύλες.
Έτσι μπορούμε να γράψουμε

```tut:silent:book
object Example {
  val good = "Good"
  
  // Create a new scope
  {
    val morning = good ++ " morning" 
    val toYou = morning ++ " to you"
  }
  
  val day = good ++ " day, sir!"
}
```

το `morning` (και το `toYou`) είναι δηλωμένα μέσα σε μία νέα εμβέλεια. Δεν υπάρχει τρόπος να αναφερθούμε σ'αυτήν την εμβέλεια από έξω (δεν έχει όνομα) άρα δεν μπορούμε να αναφερθούμε στο `morning` εκτός της εμβέλειας μέσα στην οποία είναι δηλωμένο.
Αν είχαμε μυστικά που δεν θα θέλαμε να τα μάθει το υπόλοιπο πρόγραμμα, αυτός θα ήταν ένας πολύ καλός τρόπος να τα κρύψουμε.

Ο τρόπος με τον οποίο λειτουργούν οι εμφωλευμένες (??) εμβέλειες στην Scala καλείται *lexical scoping*.
Δεν έχουν όλες οι γλώσσες lexical scoping.
Για παράδειγμα, η Ruby και η Python δεν έχουν, ενώ η Javascript απέκτησε lexical scoping πρόσφατα.
Η γνώμη των συγγραφέων είναι ότι η δημιουργία γλώσσας χωρίς lexical scoping είναι σαν να τρως ένα ματσάκι πιπεριών (??τρελοπιπεριών??) Γουατεμάλας και μετά να πηγαίνεις στην τουαλέτα χωρίς να πλύνεις τα χέρια σου.


### Ασκήσεις {-}

Δοκιμάστε την κατανόηση σας σχετικά με τα ονόματα και τις εμβέλειες βρίσκοντας την τιμή του `answer` σε κάθε μια από τις παρακάτω περιπτώσεις.

```tut:silent:book
val a = 1
val b = 2
val answer = a + b
```

<div class="solution">
Ένα απλό παράδειγμα για να ξεκινήσετε. Το `answer` είναι `1 + 2`, δηλαδή `3`.
</div>

```tut:silent:book
object One {
  val a = 1

  object Two {
    val a = 3
    val b = 2
  }

  object Answer {
    val answer = a + Two.b
  }
}
```

<div class="solution">
Ακόμα ένα απλό παράδειγμα. Το `answer` είναι `1 + 2`, δηλαδή `3`. Το `Two.a` δεν είναι σε εμβέλεια εκεί που είναι ορισμένο το `answer`.
</div>

```tut:silent:book
object One {
  val a = 5
  val b = 2
  
  object Answer {
    val a = 1
    val answer = a + b
  }
}
```

<div class="solution">
Εδώ το `Answer.a` επισκιάζει το `One.a` άρα το `answer` είναι `1 + 2`, δηλαδή `3`.
</div>

```tut:silent:book
object One {
  val a = 1
  val b = a + 1
  val answer = a + b
}
```

<div class="solution">
Αυτό είναι μια χαρά. Η έκφραση `a + 1` στην δεξιά μεριά της δήλωσης του `b` είναι μια έκφραση όπως όλες τις άλλες άρα το `answer` είναι και πάλι `3`.
</div>

```tut:silent:book
object One {
  val a = 1
  
  object Two {
    val b = 2
  }
  
  val answer = a + b
}
```

<div class="solution">
Αυτός ο κώδικας δεν θα μεταγλωττιστεί αφού το `b` δεν είναι σε εμβέλεια εκεί που έχει οριστεί το `answer`.
</div>

```tut:fail:silent:book
object One {
  val a = b - 1
  val b = a + 1
  
  val answer = a + b
}
```

<div class="solution">
Ερώτηση παγίδα! Αυτός ο κώδικας δεν δουλεύει. Εδώ το `a` και το `b` είναι ορισμένα έτσι ώστε να έχουν σχέση μεταξύ τους κατι το οποίο όδηγεί σε αλληλοεξάρτηση που δεν μπορεί να επιλυθεί.
</div>

