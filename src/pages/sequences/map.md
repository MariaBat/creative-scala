## Μετατρέποντας Σειρές

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Έχουμε δει ότι χρησιμοποιώντας δομημένη αναδρομή μπορούμε να δημιουργήσουμε λίστες και να τις μετασχηματίσουμε σε κάτι άλλο. Αυτός ο τρόπος είναι αρκετά απλός στην χρήση και στην κατανόησή του όμως απαιτεί το γράψιμο του ίδιου σκελετού ξανά και ξανά.
Σε αυτή την ενότητα θα μάθουμε ότι σε μερικές περιπτώσεις μπορούμε να αντικαταστήσουμε την δομημένη αναδρομή χρησιμοποιώντας μία μέθοδο της `List` η οποία ονομάζεται `map`.
Θα δούμε επίσης ότι και άλλοι τύποι δεδομένων μπορούν να μας παρέχουν αυτή τη μέθοδο και ότι μπορούμε να την χρησιμοποιήσουμε ως έναν εύκολο τρόπο διαχείρισης σειρών.


### Μετατρέποντας τα Στοιχεία των Λιστών

Στην προηγούμενη ενότητα είδαμε σε διάφορα παραδείγματα λίστες να μετατρέπονται σε άλλες λίστες.
Για παράδειγμα, προσθέσαμε μία τιμή σε όλα τα στοιχεία μίας λίστας χρησιμοποιώντας τον παρακάτω κώδικα.

```tut:book
def increment(list: List[Int]): List[Int] =
  list match {
    case Nil => Nil
    case hd :: tl => (hd + 1) :: tl
  }
  
increment(List(1, 2, 3))
```

Σ' αυτό το παράδειγμα, δεν αλλάζει η *δομή* της λίστας.
Αν ξεκινήσουμε με τρία στοιχεία, τελειώνουμε με τρία στοιχεία.
Μπορούμε να αντικαταστήσουμε τον παραπάνω τρόπο με μία μέθοδο που ονομάζεται `map`.
Αν έχουμε μία λίστα με δεδομένα τύπου `A`, περνάμε στην `map` μία συνάρτηση τύπου `A => B` και παίρνουμε πίσω μία λίστα της οποίας τα στοιχεία είναι τύπου `B`.
Για παράδειγμα, μπορούμε να υλοποιήσουμε την `increment` χρησιμοποιώντας την `map` με την συνάρτηση `x => x + 1`.

```tut:book
def increment(list: List[Int]): List[Int] =
  list.map(x => x + 1)
  
increment(List(1, 2, 3))
```

Κάθε στοιχείο μετασχηματίζεται σύμφωνα με την συνάρτηση που περνάμε στην `map`, σ' αυτή την περίπτωση έχουμε την `x => x + 1`.
Με την `map` μπορούμε να μετασχηματίσουμε τα στοιχεία μίας λίστας αλλά δεν μπορούμε να αλλάξουμε το πόσα είναι.

Η παρακάτω αναπαράσταση με γραφικά θα σας βοηθήσει στην κατανόηση της `map`.
Αν έχουμε έναν τύπο `Circle` τότε μπορούμε να ζωγραφίσουμε μία `List[Circle]` σαν κουτί που περιέχει έναν κύκλο, όπως φαίνεται στην εικόνα  [@fig:sequences:circle-box].

![Μία `List[Circle]` που αναπαρίσταται από έναν κύκλο μέσα σε ένα κουτί](./src/pages/sequences/circle-box.pdf+svg){#fig:sequences:circle-box}

Τώρα μπορούμε να σχεδιάσουμε μία εξίσωση για την `map` όπως φαίνεται στην εικόνα [@fig:sequences:map].
Αν προτιμάτε τα σύμβολα από τις εικόνες, η εικόνα αναπαριστά το `List[Circle] map (Circle => Triangle) = List[Triangle]`.
Ένα πλεονέκτημα της γραφικής αυτής αναπαράστασης είναι ότι παρουσιάζει πολύ καλά το ότι η `map` δεν μπορεί να δημιουργήσει ένα νέο "κουτί" που θα αναπαριστά την δομή της λίστας---ή πιο σωστά, δεν μπορεί να αλλάξει τον αριθμό των στοιχείων της και την σειρά τους.

![Γραφική αναπαράσταση της `map`](./src/pages/sequences/map.pdf+svg){#fig:sequences:map}

Η γραφική αναπαράσταση της `map` δείχνει τι ακριβώς συμβαίνει με τους τύπους που χρησιμοποιεί.
Αν το προτιμάτε, μπορούμε να παρουσιάσουμε το ίδιο και με σύμβολα:

```scala
List[A] map (A => B) = List[B]
```

Στην αριστερή πλευρά της εξίσωσης υπάρχει ο τύπος της λίστας που περνάμε από την map καθώς και η συνάρτηση που θα χρησιμοποιήσουμε για την μετατροπή.
Στην δεξιά πλευρά, βρίσκεται ο τύπος του αποτελέσματος.


### Μετατρέποντας Σειρές Αριθμών

Έχουμε ήδη γράψει πολλές μεθόδους που μετατρέπουν φυσικούς αριθμούς σε λίστες.
Επίσης συζητήσαμε περιληπτικά για το πώς μπορούμε να αναπαραστήσουμε έναν φυσικό αριθμό ως λίστα.
Το `3` είναι ισοδύναμο με το `1 + 1 + 1 + 0`, το οποίο με την σειρά του θα μπορούσε να αναπαρασταθεί από μία λίστα `List(1, 1, 1)`.
Άρα;
Αυτό σημαίνει ότι θα μπορούσαμε να γράψουμε πολλές από τις μεθόδους οι οποίες δέχονται φυσικούς αριθμούς, ως μεθόδους που δουλεύουν με λίστες.

Για παράδειγμα, αντί για

```tut:book
def fill[A](n: Int, a: A): List[A] =
  n match {
    case 0 => Nil
    case n => a :: fill(n-1, a)
  }
  
fill(3, "Hi")
```

θα μπορούσαμε να γράψουμε

```tut:book
def fill[A](n: List[Int], a: A): List[A] =
  n.map(x => a)
  
fill(List(1, 1, 1), "Hi")
```

Είναι πιο εύκολο να γράψουμε αυτή την εκδοχή της `fill` αλλά για τον χρήστη δεν είναι είναι τόσο βολικό να την καλέσει με το `List(1, 1, ,1)` αντί να την καλέσει απλώς με το `3`.


Αν θέλουμε να δουλέψουμε με σειρές αριθμών, καλύτερα να χρησιμοποιήσουμε τα `Ranges` (διαστήματα).
Μπορούμε να τα δημιουργήσουμε χρησιμοποιώντας την μέθοδο `until` αντί για το `Int` ή το `Double`:

```tut:book
0 until 10
0.0 until 5.0
```

τα `Ranges` έχουν μία μέθοδο `by` η οποία μας επιτρέπει να αλλάξουμε το βήμα μεταξύ των στοιχείων της ακολουθίας:

```tut:book
0 until 10 by 2
0.0 until 1.0 by 0.3
```

τα `Ranges` έχουν και αυτά μία μέθοδο `map` ακριβώς όπως και η `List`

```tut:book
(0 until 3) map (x => x + 1) 
```

Θα παρατηρήσατε ότι ο τύπος του αποτελέσματος είναι ο `IndexedSeq` ο οποίος τελικά υλοποιείται ως `Vector`---δύο τύποι που δεν τους έχουμε δει ακόμα.
Μπορούμε να φτιάξουμε ένα `IndexedSeq` όπως φτιάχνουμε και μία `List` αλλά για λόγους απλότητας μπορούμε να μετατρέψουμε ένα `Range` ή ένα `IndexedSeq` σε ένα  `List` χρησιμοποιώντας την μέθοδο `toList`.

```tut:book
(0 until 7).toList
(0 until 3).map(x => x + 1).toList
```

Με τα `Ranges` στην εργαλειοθήκη μας, μπορούμε να γράψουμε την `fill` ως εξής

```tut:book
def fill[A](n: Int, a: A): List[A] =
  (0 until n).toList.map(x => a)
  
fill(3, "Hi")
```

#### Ασκήσεις{-}

##### Ranges, Lists και Map {-}

Γράψτε ξανά τις παρακάτω μεθόδους χρησιμοποιώντας τα νέα εργαλεία που μάθαμε παραπάνω.

Γράψτε μία μέθοδο με όνομα `ones` η οποία δέχεται έναν `Int` με όνομα `n` και επιστρέφει μία `List[Int]` μήκους `n` που όλα της τα στοιχεία είναι `1`. Για παράδειγμα

```tut:invisible
def ones(n: Int): List[Int] =
  (0 until n).toList.map(x => 1)
```

```tut:book
ones(3)
```

<div class="solution">
Για να το καταφέρουμε, μπορούμε να χρησιμοποιήσουμε την `map` για ένα συγκεκριμένο `Range`.

```tut:book
def ones(n: Int): List[Int] =
  (0 until n).toList.map(x => 1)
  
ones(3)
```
</div>


Γράψτε μία μέθοδο με όνομα `descending` η οποία δέχεται έναν φυσικό αριθμό `n` και επιστρέφει μία `List[Int]` η οποία περιέχει τους φυσικούς αριθμούς από το `n` ως το `1` ή αν η λίστα είναι άδεια δηλαδή το `n` είναι μηδέν, επιστρέφει την άδεια λίστα. Για παράδειγμα

```tut:invisible
def descending(n: Int): List[Int] =
  (n until 0 by -1).toList
```

```tut:book
descending(0)
descending(3)
```

<div class="solution">
Μπορούμε να χρησιμοποιήσουμε ένα `Range` αλλά θα πρέπει να ρυθμίσουμε και το βήμα γιατί αλλιώς το πρόγραμμα δεν θα γνωρίζει τι να κάνει.

```tut:book
def descending(n: Int): List[Int] =
  (n until 0 by -1).toList

descending(0)
descending(3)
```

</div>


Γράψτε μία μέθοδο με όνομα `ascending` η οποία δέχεται έναν φυσικό αριθμό `n` και επιστρέφει μία `List[Int]` η οποία περιέχει τους φυσικούς αριθμούς από το `1` μέχρι το `n` ή αν το `n` είναι μηδέν, επιστρέφει την άδεια λίστα.

```tut:invisible
def ascending(n: Int): List[Int] =
  (0 until n).toList.map(x => x + 1)
```

```tut:book
ascending(0)
ascending(3)
```

<div class="solution">
Μπορούμε να χρησιμοποιήσουμε το `Range` και πάλι αλλά θα πρέπει να ξεκινήσουμε από το `0` και να αυξάνουμε τα στοιχεία κατά `1` ώστε να έχουμε τον σωστό αριθμό στοιχείων.

```tut:book
def ascending(n: Int): List[Int] = 
  (0 until n).toList.map(x => x + 1)
  
ascending(0)
ascending(3)
```
</div>


Γράψτε μία μέθοδο με όνομα `double` η οποία δέχεται μία `List[Int]` και επιστρέφει μία λίστα όπου κάθε της στοιχείο είναι διπλασιασμένο.

```tut:invisible
def double(list: List[Int]): List[Int] =
  list map (x => x * 2)
```

```tut:book
double(List(1, 2, 3))
double(List(4, 9, 16))
```

<div class="solution">
Εδώ ξεκάθαρα πρέπει να χρησιμοποιήσουμε την `map`.

```tut:book
def double(list: List[Int]): List[Int] =
  list map (x => x * 2)

double(List(1, 2, 3))
double(List(4, 9, 16))
```
</div>


##### Πάλι Πολύγωνα! {-}

Χρησιμοποιώντας τα νέα μας εργαλεία, γράψτε και πάλι την μέθοδο `polygon` που είχαμε δει στην προηγούμενη ενότητα.


<div class="solution">
Πρακάτω μπορείτε να δείτε μία πιθανή λύση. Είναι πολύ πιο εύκολο να την διαβάσετε από την προηγούμενη λύση!

```tut:silent:book
def polygon(sides: Int, size: Int, initialRotation: Angle): Image = {
  import Point._
  import PathElement._

  val step = (Angle.one / sides).toDegrees
  val path = 
    (0.0 to 360.0 by step).toList.map{ deg => 
      lineTo(polar(size, initialRotation + deg.degrees))
    }
    
  closedPath(moveTo(polar(size, initialRotation)) :: path)
}
```
</div>


##### Άσκηση Πρόκληση: Πέρα από την Map {-}

Μπορούμε να χρησιμοποιήσουμε την `map` για να αντικαταστήσουμε όλες τις χρήσεις της δομημένης αναδρομής;
Αν όχι, μπορείτε να αναφέρετε τα προβλήματα που δεν μπορούμε να λύσουμε με την `map` αλλά μπορούμε να λύσουμε με γενική δομημένη αναδρομή σε λίστες;

<div class="solution">
Έχουμε δει πολλά παραδείγματα στα οποία δεν θα μπορούσαμε να χρησιμοποιήσουμε την `map`: οι μέθοδοι `product`, `sum`, `find`, καθώς και άλλες πολλές στην προηγούμενη ενότητα δεν μπορούν να υλοποιηθούν με την `map`.

Γενικά, οι μέθοδοι που υλοποιούνται με map ακολουθούν την παρακάτω εξίσωση:

```bash
List[A] map A => B = List[B]
```

Αν το αποτέλεσμα δεν είναι τύπου `List[B]` τότε δεν μπορούμε να την υλοποιήσουμε με `map`.
Για παράδειγμα, μέθοδοι όπως οι `product` και `sum` μετατρέπουν μία `List[Int]` σε `Int` και άρα δεν μπορούμε να τις φτιάξουμε χρησιμοποιώντας `map`.

Η `Map` μετασχηματίζει τα στοιχεία μίας λίστας αλλά δεν μπορεί να αλλάξει τον αριθμό των στοιχείων στο αποτέλεσμα.
Ακόμη και αν μία μέθοδος ταιριάζει στην παραπάνω εξίσωση, αν απαιτείται αλλαγή του αριθμού στοιχείων της λίστας τότε δεν θα μπορέσει να υλοποιηθεί με την `map`.
</div>


### Εργαλεία της Ranges

Είδαμε την μέθοδο `until` για κατασκευή της `Ranges` και την `by` για αλλαγή του βήματος της.
Υπάρχει όμως και άλλη μία μέθοδος η οποία είναι χρήσιμη: η `to`.
Αυτήν κατασκευάζει μία `Range` όπως και η `until` αλλά της δίνει ένα σημείο τερματισμού.
Συγκρίνετε τα παρακάτω

```tut:book
1 until 5
1 to 5
```

Χρησιμοποιώντας τεχνικούς όρους, η `Range` που έχει κατασκευαστεί με `until` ορίζει ένα *μισό-ανοιχτό διάστημα* (??πώς??), ενώ αυτήν που έχει κατασκευαστεί με την `to` ορίζει ένα *ανοιχτό διάστημα*.

#### Ασκήσεις {-}

##### Χρησιμοποιώντας Ανοιχτά Διαστήματα {-}

Γράψτε μία μέθοδο με όνομα `ascending` η οποία δέχεται έναν φυσικό αριθμό `n` και επιστρέφει μία `List[Int]` η οποία περιέχει τους φυσικούς αριθμούς από το `1` ως το `n` ή αν το `n` είναι μηδέν, επιστρέφει την άδεια λίστα.
*Βοήθεια:* χρησιμοποιήστε την `to`

```tut:invisible
def ascending(n: Int): List[Int] =
  (1 to n).toList
```

```tut:book
ascending(0)
ascending(3)
```

<div class="solution">
Τώρα που μάθαμε την `to` η υλοποιηση της `ascending` είναι πολύ εύκολη.

```tut:book
def ascending(n: Int): List[Int] = 
  (1 to n).toList
  
ascending(0)
ascending(3)
```
</div>
