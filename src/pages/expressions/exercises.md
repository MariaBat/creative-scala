## Ασκήσεις

#### Αριθμητική

Γράψτε μία έκφραση στην οποία να χρησιμοποιείτε ακέραιες κυριολεκτικές εκφράσεις, πρόσθεση και αφαίρεση και να έχει ως αποτέλεσμα το 42.

<div class="solution">
Ο σκοπός αυτής της άσκησης είναι να συνηθίσετε να γράφετε κώδικα σε Scala. Παρακάτω δίνεται μία πιθανή λύση.

```tut:book
1 + 43 - 2
```
</div>


#### Ενώνοντας Strings

Ενώστε δύο strings (τεχνική γνωστή ως *appending* strings) χρησιμοποιώντας την μέθοδο `++`. Γράψτε ισοδύναμες εκφράσεις χρησιμοποιώντας τον κλασικο τροπο με κλήση μεθόδου αλλά και αυτόν με operator.

<div class="solution">
Παρακάτω μπορείτε να δείτε μία πιθανή λύση.

```tut:book
"It is a truth ".++("universally acknowledged")
"It is a truth " ++ "universally acknowledged"
```
</div>

#### Προτεραιότητα

Στα μαθηματικά έχουμε μάθει ότι κάποιοι τελεστές έχουν *προτεραιότητα* έναντι κάποιων άλλων. Για παράδειγμα, στην έκφραση `1 + 2 * 3` ο πολλαπλασιασμός θα πρέπει να γίνει πριν την πρόσθεση. Ισχύουν οι ίδιοι κανόνες στην Scala;

<div class="solution">
Λίγη εξάσκηση με την κονσόλα θα πρέπει να σας πείσει ότι ναι, στη Scala ισχύουν οι ίδιοι κανόνες προτεραιότητας. Δείτε το επόμενο παράδειγμα.

```tut:book
1 + 2 * 3
1 + (2 * 3)
(1 + 2) * 3
```
</div>


#### Τύποι και τιμές

Ποιες από τις παρακάτω εκφράσεις δεν θα μεταγλωττιστούν; Ποίος είναι ο τύπος αυτών που θα μεταγλωττιστούν; Ποιες εκφράσεις θα αποτύχουν στην εκτέλεση;

```tut:silent
1 + 2
```

```tut:silent
"3".toInt
```

```tut:fail:silent
"Electric blue".toInt
```

```tut:silent
"Electric blue".take(1)
```

```tut:fail:silent
"Electric blue".take("blue")
```

```tut:silent
1 + ("Moonage daydream".indexOf("N"))
```

```tut:silent
1 / 1 + ("Moonage daydream".indexOf("N"))
```

```tut:fail:silent
1 / (1 + ("Moonage daydream".indexOf("N")))
```

<div class="solution">
```tut:book
1 + 2
```

Ο τύπος της έκφρασης είναι `Int` και το αποτέλεσμα είναι `3`.


```tut:book
"3".toInt
```

Ο τύπος της έκφρασης είναι `Int` και το αποτέλεσμα είναι `3`.

```tut:fail:book
"Electric blue".toInt
```

Ο τύπος της έκφρασης είναι `Int` αλλά θα αποτύχει στην εκτέλεση.

```tut:silent
"Electric blue".take(1)
```

Ο τύπος της έκφρασης είναι `String` και το αποτέλεσμα είναι `"E"`.

```tut:fail:book
"Electric blue".take("blue")
```

Η έκφραση θα αποτύχει στην μεταγλώττιση άρα δεν έχει τύπο.

```tut:book
1 + ("Moonage daydream".indexOf("N"))
```

Ο τύπος της έκφρασης είναι `Int` και το αποτέλεσμα είναι  `0`.

```tut:book
1 / 1 + ("Moonage daydream".indexOf("N"))
```

Ο τύπος της έκφρασης είναι `Int` και λόγω των κανόνων προτεραιότητας το αποτέλεσμα είναι  `(1 / 1) + -1`, άρα `0`.

```tut:fail:silent
1 / (1 + ("Moonage daydream".indexOf("N")))
```

Ο τύπος της έκφρασης είναι `Int` αλλά και αυτή θα αποτύχει στην εκτέλεση λόγω διαίρεσης με το μηδέν.
</div>

#### Αστοχίες κινητής υποδιαστολής

Όταν σας συστήσαμε τους Doubles, σας είπαμε ότι είναι μία προσέγγιση των πραγματικών αριθμών. Γιατί νομίζετε ότι συμβαίνει αυτό; Σκεφτείτε την αναπαράσταση αριθμών όπως το ⅓ και το π. Πόσος χώρος θα χρειάζονταν για να αναπαρασταθούν αυτοί οι αριθμοί στο δεκαδικό;

<div class="solution">
Οι `Double` είναι μία προσέγγιση αφού πρέπει να χωρέσουν μέσα στην πεπερασμένη μνήμη του υπολογιστή. Ένας `Double` καταλαμβάνει ακριβώς 64-bits, που είναι αρκετός χώρος για να αποθηκευτούν πολλά ψηφία αλλά όχι τόσος ώστε να αποθηκευτούν αριθμοί όπως το π, το οποίο έχει άπειρα δεκαδικά ψηφία.

Ο αριθμός ⅓ έχει επίσης άπειρα δεκαδικά ψηφία. Αφού οι `Doubles` αποθηκεύονται στο δυαδικό υπάρχουν μερικοί αριθμοί που μπορούν να αναπαρασταθούν με έναν πεπερασμένο αριθμό δεκαδικών ψηφίων αλλά δεν έχουν πεπερασμένη αναπαράσταση στο δυαδικό. Το 0.1 είναι ένας τέτοιος αριθμός.

Γενικά, οι αριθμοί κινητής υποδιαστολής μπορεί να οδηγήσουν σε άσχημες καταστάσεις αν περιμένετε από αυτούς να φερθούν όπως οι πραγματικοί. Η χρήση τους αρκεί για αυτά που θα κάνουμε στην Creative Scala, αλλά καλύτερα να μην τους χρησιμοποιήσετε για να γράψετε λογιστικό λογισμικό!
</div>

#### Πέρα από τις Εκφράσεις

Στο τωρινό μας υπολογιστικό μοντέλο υπάρχουν μόνο τρία συστατικά στοιχεία: οι εκφράσεις (το κείμενο του προγράμματος) με τους αντίστοιχους τύπους τους, που έχουν ως αποτέλεσμα τιμές (που υπάρχουν μέσα στη μνήμη του υπολογιστή). Είναι όμως αυτό αρκετό; Θα μπορούσαμε να γράψουμε ένα πρόγραμμα που θα χρησιμοποιηθεί στο χρηματιστήριο ή ένα παιχνίδι για υπολογιστή μόνο με αυτό το μοντέλο; Μπορείτε να σκεφτείτε τρόπους επέκτασης αυτού του μοντέλου;

<div class="solution">
Αυτή είναι μία ερώτηση με πολύ γενική απάντηση. Υπάρχουν διάφοροι τρόποι ώστε να ξεπεράσουμε το μοντέλο που ξέρουμε μέχρι τώρα.

Για να είναι τα προγράμματά μας χρήσιμα πρέπει να είναι ικανά να δημιουργούν έναν αντίκτυπο---αλλαγές στον κόσμο που ξεπερνούν τα όρια της μνήμης του υπολογιστή. Για παράδειγμα, να μπορούν να εμφανίζουν πράγματα στην οθόνη, να αναπαράγουν ήχους, να στέλνουν μηνύματα σε άλλους υπολογιστές και ούτω καθεξής. Η κονσόλα κάνει κάποια από αυτά για εμάς, εκτυπώνοντας τιμές στην οθόνη. Θα πρέπει να πάμε και λίγο πιο πέρα από αυτά για να καταφέρουμε να φτιάξουμε πιό χρήσιμα προγράμματα.

Επίσης, δεν έχουμε μάθει ακόμη κάποιον τρόπο ώστε να μπορούμε να ορίζουμε δικά μας αντικείμενα και μεθόδους ή να επαναχρησιμοποιήσουμε τιμές στα προγράμματά μας. Αν, για παράδειγμα, θέλαμε να χρησιμοποιήσουμε το όνομα κάποιου πολλές φορές σε ένα πρόγραμμα μας, θα έπρεπε κάθε φορά που το χρειαζόμαστε να το ξαναγράφουμε. Πρέπει να μάθουμε περισσότερες μεθόδους *αφαιρετικότητας* και θα φτάσουμε και σε αυτό το επίπεδο πολύ σύντομα.
</div>
