## Ασκήσεις

#### Αριθμητική

Γράψτε μια έκφραση χρησιμοποιώντας ακέραια κυριολεκτικά, πρόσθεση και αφαίρεση και θα έχει ως αποτέλεσμα το 42.

<div class="solution">
Ο σκοπός αυτής της άσκησης είναι να συνηθίσετε να γράφετε κώδικα σε Scala. Παρακάτω δίνεται μια πιθανή λύση.

```tut:book
1 + 43 - 2
```
</div>


#### Ενώνοντας Strings

Ενώστε δύο strings (τεχνική γνωστή ως *appending* strings) χρησιμοποιώντας την μέθοδο `++`. Γράψτε ισοδύναμες εκφράσεις χρησιμοποιώντας την κανονική μέθοδο αλλά και αυτήν με operator.

<div class="solution">
Κάτι σαν το παρακάτω θα πρέπει να δουλεύει.

```tut:book
"It is a truth ".++("universally acknowledged")
"It is a truth " ++ "universally acknowledged"
```
</div>

#### Προτεραιότητα

Στα μαθηματικά έχουμε μάθει ότι κάποιοι συντελεστές (operators) έχουν *προτεραιότητα* έναντι κάποιων άλλων. Για παράδειγμα, στην έκφραση `1 + 2 * 3` θα πρέπει να κάνουμε τον πολλαπλασιασμό πριν την πρόσθεση. Ισχύουν οι ίδιοι κανόνες στην Scala;

<div class="solution">
Λίγη εξάσκηση με την κονσόλα θα πρέπει να σας πείσει ότι ναι, στη Scala ισχύουν οι ίδιοι κανόνες προτεραιότητας. Το επόμενο παράδειγμα δείχνει ακριβώς αυτό.

```tut:book
1 + 2 * 3
1 + (2 * 3)
(1 + 2) * 3
```
</div>


#### Τύποι και τιμές

Ποιες από τις παρακάτω εκφράσεις δεν θα μεταγλωττιστούν; Ποίος είναι ο τύπος αυτών που θα μεταγλωττιστούν; Ποιες εκφράσεις θα αποτύχουν στην εκτέλεση;

```tut:silent
1 + 2
```

```tut:silent
"3".toInt
```

```tut:fail:silent
"Electric blue".toInt
```

```tut:silent
"Electric blue".take(1)
```

```tut:fail:silent
"Electric blue".take("blue")
```

```tut:silent
1 + ("Moonage daydream".indexOf("N"))
```

```tut:silent
1 / 1 + ("Moonage daydream".indexOf("N"))
```

```tut:fail:silent
1 / (1 + ("Moonage daydream".indexOf("N")))
```

<div class="solution">
```tut:book
1 + 2
```

Ο τύπος της έκφρασης είναι `Int` και το αποτέλεσμα είναι `3`.


```tut:book
"3".toInt
```

Ο τύπος της έκφρασης είναι `Int` και το αποτέλεσμα είναι `3`.

```tut:fail:book
"Electric blue".toInt
```

Ο τύπος της έκφρασης είναι `Int` αλλά θα αποτύχει στην εκτέλεση.

```tut:silent
"Electric blue".take(1)
```

Ο τύπος της έκφρασης είναι `String` και το αποτέλεσμα είναι `"E"`.

```tut:fail:book
"Electric blue".take("blue")
```

Η έκφραση θα αποτύχει στην μεταγλώττιση άρα δεν έχει τύπο.

```tut:book
1 + ("Moonage daydream".indexOf("N"))
```

Ο τύπος της έκφρασης είναι `Int` και το αποτέλεσμα είναι  `0`.

```tut:book
1 / 1 + ("Moonage daydream".indexOf("N"))
```

Ο τύπος της έκφρασης είναι `Int` και λόγω της προτεραιότητας το αποτέλεσμα είναι  `(1 / 1) + -1`, άρα `0`.

```tut:fail:silent
1 / (1 + ("Moonage daydream".indexOf("N")))
```

Ο τύπος της έκφρασης είναι `Int` αλλά επίσης θα αποτύχει στην εκτέλεση με μια διαίρεση με το μηδέν.
</div>

#### Αστοχίες κινητής υποδιαστολής

Όταν σας συστήσαμε τους Doubles`, σας είπαμε ότι είναι μια προσέγγιση των αληθινών αριθμών. Γιατί νομίζετε ότι συμβαίνει αυτό; Σκεφτείτε την αναπαράσταση αριθμών όπως το ⅓ και το π. Πόσος χώρος θα χρειάζονταν για να αναπαρασταθούν αυτοί οι αριθμοί στο δεκαδικό;

<div class="solution">
Οι `Double` είναι μια προσέγγιση αφού πρέπει να χωρέσουν μέσα στην πεπερασμένη μνήμη του υπολογιστή. Ένας `Double` πιάνει ακριβώς 64-bits, που είναι αρκετός χώρος για να αποθηκευτούν πολλά ψηφία αλλά όχι τόσος ώστε να αποθηκευτούν αριθμοί όπως το π, που έχει άπειρη επέκταση.

Ο αριθμός ⅓ έχει επίσης άπειρη επέκταση στο δεκαδικό. Αφού οι `Doubles` αποθηκεύονται στο δυαδικό υπάρχουν μερικοί αριθμοί που μπορούν να αναπαρασταθούν με έναν πεπερασμένο αριθμό δεκαδικών ψηφίων αλλά δεν έχουν πεπερασμένη αναπαράσταση στο δυαδικό. Το 0.1 είναι ένας τέτοιος αριθμός.

Γενικά, οι αριθμοί κινητής υποδιαστολής μπορεί να οδηγήσουν σε άσχημες καταστάσεις αν αναμένετε από αυτούς να φερθούν όπως οι αληθινοί. Η χρήση τους αρκεί για αυτά που θα κάνουμε στην Creative Scala, αλλά καλύτερα να μην τους χρησιμοποιήσετε για να γράψετε λογιστικό λογισμικό!
</div>

#### Πέρα από τις εκφράσεις

Στο τωρινό μας μοντέλο υπολογισμού υπάρχουν μόνο τρία συστατικά στοιχεία: εκφράσεις (κείμενο προγράμματος) με τύπους, που αξιολογούνται σε τιμές (κάτι μέσα στη μνήμη του υπολογιστή). Είναι όμως αυτό αρκετό; Θα μπορούσαμε να γράψουμε ένα χρηματιστήριο(????πρόγραμμα για χρηματιστήριο???) ή ένα παιχνίδι για υπολογιστή μόνο με αυτό το μοντέλο; Μπορείτε να σκεφτείτε τρόπους επέκτασης αυτού του μοντέλου;

<div class="solution">
Αυτή είναι μια πολύ ανοιχτή ερώτηση. Υπάρχουν διάφοροι τρόποι ώστε να πάμε πέρα από το μοντέλο που ξέρουμε μέχρι τώρα.

Για να είναι τα προγράμματά μας χρήσιμα πρέπει να είναι ικανά να δημιουργούν αποτελέσματα---αλλαγές στον κόσμο που ξεπερνούν τα όρια της μνήμης του υπολογιστή. Για παράδειγμα, να μπορούν να εμφανίζουν πράγματα στην οθόνη, να αναπαράγουν ήχους, να στέλνουν μηνύματα σε άλλους υπολογιστές και ούτω καθεξής. Η κονσόλα σιωπηλά κάνει κάποια από αυτά για εμάς, εκτυπώνοντας τιμές στην οθόνη. Θα πρέπει να πάμε και λίγο πιο πέρα από αυτά για να πετύχουμε πιό χρήσιμα προγράμματα.

Επίσης, δεν ξέρουμε κάποιον τρόπο ώστε να ορίσουμε δικά μας αντικείμενα και μεθόδους ή να επαναχρησιμοποιήσουμε τιμές στα προγράμματά μας. Αν, για παράδειγμα, θέλαμε να χρησιμοποιήσουμε το όνομα κάποιου σε ένα πρόγραμμα θα έπρεπε να το επαναλαμβάνουμε παντού. Χρειαζόμαστε περισσότερες μεθόδους *αφαιρετικότητας (abstraction)* και θα φτάσουμε και σε αυτό σύντομα.
</div>
