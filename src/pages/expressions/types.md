## Τύποι

Τώρα που μπορούμε να γράψουμε πιο περίπλοκες εκφράσεις μπορούμε να μιλήσουμε λίγο παραπάνω για τους τύπους.

Μία χρήση των τύπων είναι να μας αποτρέπουν από την κλήση μεθόδων που δεν υπάρχουν. Ο τύπος μιας έκφρασης λέει στον μεταγλωττιστή ποιες μέθοδοι υπάρχουν για την τιμή με την οποία αξιολογείται. Αν προσπαθήσουμε να καλέσουμε μια μέθοδο που δεν υπάρχει, ο κώδικάς μας δεν θα μεταγλωττιστεί. Παρακάτω δίνονται μερικά απλά παραδείγματα.

```tut:fail:book
"Brontë" / "Austen"
1.take(2)
```

Πραγματικά, ο τύπος μια έκφρασης, είναι αυτός που καθορίζει ποιες μεθόδους μπορούμε να καλέσουμε, κάτι που μπορούμε να επιδείξουμε καλώντας μεθόδους στο αποτέλεσμα πιο περίπλοκων εκφράσεων.

```tut:fail:book
(1 + 3).take(1)
```

Η διαδικασία του *ελέγχου τύπου* ισχύει και για τις παραμέτρους των μεθόδων.

```tut:fail:book
1.min("zero")
```

Οι τύποι είναι ιδιοκτησία των εκφράσεων και άρα υπάρχουν μόνο κατά τον χρόνο μεταγλώττισης (όπως είχαμε αναφέρει και προηγουμένως). Αυτό σημαίνει ότι μπορούμε να καθορίσουμε τον τύπο μιας έκφρασης ακόμη και αν η αξιολόγησή της προκαλέσει λάθος κατά την διάρκεια εκτέλεσης (run-time error). Για παράδειγμα, η διαίρεση ενός ακεραίου με το μηδέν προκαλεί λάθος κατά την διάρκεια εκτέλεσης.

```tut:fail:book
1 / 0
```

Η έκφραση `1 / 0` έχει τύπο, και  μπορούμε να πάρουμε αυτόν τον τύπο από την κονσόλα όπως φαίνεται παρακάτω.

```scala
:type 1 / 0
// Int
```

Ακόμη, μπορούμε να γράψουμε μια σύνθετη έκφραση η οποία συμπεριλαμβάνει μια υπό-έκφραση η οποία θα αποτύχει κατά την διάρκεια της εκτέλεσης.

```tut:fail:book
(2 + (1 / 0) + 3)
```

Ακόμη και αυτή η έκφραση έχει τύπο.

```scala
:type (2 + (1 / 0) + 3)
// Int
```
