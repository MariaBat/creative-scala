## Τύποι

Τώρα που είμαστε σε θέση να γράψουμε περίπλοκες εκφράσεις ήρθε η ώρα να μιλήσουμε λίγο παραπάνω για τους τύπους.

Μία χρήση των τύπων είναι να μας αποτρέπουν από την κλήση μεθόδων που δεν υπάρχουν. Ο τύπος μίας έκφρασης λέει στον μεταγλωττιστή ποιες μέθοδοι υπάρχουν για την τιμή με την οποία αξιολογείται. Αν προσπαθήσουμε να καλέσουμε μία μέθοδο που δεν υπάρχει, ο κώδικάς μας δεν θα μεταγλωττιστεί. Παρακάτω δίνονται μερικά απλά παραδείγματα.

```tut:fail:book
"Brontë" / "Austen"
1.take(2)
```

Πραγματικά, ο τύπος μία έκφρασης, είναι αυτός που καθορίζει ποιες μεθόδους μπορούμε να καλέσουμε, κάτι που μπορούμε να επιδείξουμε καλώντας μεθόδους που αντιστοιχούν σε αποτελέσματα πιο περίπλοκων εκφράσεων.

```tut:fail:book
(1 + 3).take(1)
```

Αυτή η διαδικασία *ελέγχου του τύπου* εφαρμόζεται και στις παραμέτρους των μεθόδων.

```tut:fail:book
1.min("zero")
```

Οι τύποι είναι ιδιότητα των εκφράσεων, επομένως υπάρχουν μόνο κατά τον χρόνο μεταγλώττισης (όπως έχουμε αναφέρει προηγουμένως). Αυτό σημαίνει ότι μπορούμε να καθορίσουμε τον τύπο μίας έκφρασης ακόμη και αν η αξιολόγισή της έχει ως αποτέλεσμα την εμφάνιση λάθους κατά τον χρόνο εκτέλεσης (run-time error). Για παράδειγμα, η διαίρεση ενός ακεραίου με το μηδέν θα προκαλέσει ένα τέτοιο λάθος.

```tut:fail:book
1 / 0
```

Η έκφραση `1 / 0` έχει τύπο και μπορούμε να μάθουμε ποιος είναι αυτός, χρησιμοποιώντας την κονσόλα όπως φαίνεται παρακάτω.

```scala
:type 1 / 0
// Int
```

Ακόμη, ο λόγος εμφάνισης λάθους κατά την εκτέλεση μπορεί να είναι μία υπό-έκφραση μέσα σε μία σύνθετη έκφραση όπως παρακάτω.

```tut:fail:book
(2 + (1 / 0) + 3)
```

Ακόμη και αυτή η έκφραση έχει τύπο.

```scala
:type (2 + (1 / 0) + 3)
// Int
```
