## Σειρά Αξιολόγησης

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Σ' αυτή την ενότητα θα ασχοληθούμε με την σειρά αξιολόγησης.
Ίσως αναρωτιέστε αν όντως έχει σημασία.
Στα παραδείγματα που είδαμε μέχρι τώρα, η σειρά δεν φάνηκε να είχε κάποια ιδιαίτερη σημασία, εκτός βέβαια από την περίπτωση στην οποία δεν μπορούσαμε να αξιολογήσουμε μία έκφραση, πριν αξιολογήσουμε τις υπό-εκφράσεις της.

Για να ερευνήσουμε αυτά τα θέματα περισσότερο θα πρέπει να εισάγουμε μία νέα έννοια.
Μέχρι εδώ έχουμε ασχοληθεί μόνο με *pure* εκφράσεις.
Τέτοιες είναι οι εκφράσεις στις οποίες μπορούμε να κάνουμε αντικαταστάσεις με οποιαδήποτε σειρά [^ειδικές-περιπτώσεις].

Στις *impure* εκφράσεις, η σειρά αξιολόγησης παίζει καθοριστικό ρόλο.
Έχουμε ήδη χρησιμοποιήσει μία τέτοια έκφραση, την μέθοδο `draw`.
Αν αξιολογήσουμε τo

```scala
Image.circle(100).draw
Image.rectangle(100, 50).draw
```

και τo

```scala
Image.rectangle(100, 50).draw
Image.circle(100).draw
```

οι εικόνες θα εμφανιστούν με διαφορετική σειρά.
Σε αυτό το παράδειγμα δεν φαίνεται η σημασία της διαφοράς.

Το κλειδί για να ξεχωρίζουμε τις impure εκφράσεις είναι ότι η αξιολόγησή τους έχει ως αποτέλεσμα κάποια αλλαγή που μπορούμε να παρατηρήσουμε.
Για παράδειγμα, η αξιολόγηση της `draw` έχει ως αποτέλεσμα την εμφάνιση μίας εικόνας.
Αυτές τις εύκολα ορατές αλλαγές τις ονομάζουμε *side effects* ή απλώς *effects* για συντομία.
Σε ένα πρόγραμμα το οποίο περιέχει side effects δεν μπορούμε να κάνουμε αντικαταστάσεις ελεύθερα.
Μπορούμε όμως να χρησιμοποιήσουμε side effects ώστε να ερευνήσουμε την σειρά αξιολόγησης.
Το εργαλείο που χρησιμοποιούμε σ' αυτή την περίπτωση είναι η μέθοδος `println`.

Η μέθοδος `println` εμφανίζει κείμενο στην κονσόλα (ένα side effect) και αξιολογείται ως unit.
Δείτε ένα παράδειγμα:

```tut:book
println("Hello!")
```

Το side-effect του `println`---εμφάνιση κειμένου στην κονσόλα---μας δίνει έναν βολικό τρόπο για να ερευνήσουμε την σειρά αξιολόγησης.
Για παράδειγμα, το αποτέλεσμα της εκτέλεσης του παρακάτω κώδικα

```tut:book
println("A")
println("B")
println("C")
```

υποδεικνύει ότι οι εκφράσεις αξιολογούνται από πάνω προς τα κάτω.
Ας χρησιμοποιήσουμε το `println` για περαιτέρω διερεύνηση.


### Ασκήσεις {-}

#### Αντικαταστάσεις και Println {-}

Σε ένα pure πρόγραμμα, μπορούμε να δώσουμε όνομα σε οποιαδήποτε έκφραση. Όταν την χρησιμοποιήσουμε ξανά, μπορούμε να την αντικαταστήσουμε με το όνομά της.
Συνεπώς, μπορούμε να ξαναγράψουμε την έκφραση

```tut:silent:book
(2 + 2) + (2 + 2)
```

ως

```tut:silent:book
val a = (2 + 2)
a + a
```

και το αποτέλεσμα του προγράμματος δεν αλλάζει.

Χρησιμοποιώντας την `println` βλέπουμε ότι οι impure εκφράσεις, με τα side effects τους, χαλάνε την διαδικασία της αντικατάστασης.

<div class="solution">
Παρακάτω μπορείτε να βρείτε ένα απλό παράδειγμα με println.
Τα δύο επόμενα προγράμματα είναι εμφανώς διαφορετικά.

```tut:book
println("Happy birthday to you!")
println("Happy birthday to you!")
println("Happy birthday to you!")
```

```tut:book
val a = println("Happy birthday to you!")
a
a 
a
```

Έτσι βλέπουμε ότι δεν μπορούμε να χρησιμοποιήσουμε την μέθοδο της αντικατάστασης ελεύθερα υπό την παρουσία των side effects και πρέπει να λάβουμε υπόψη την σειρά αξιολόγησης.
</div>


#### Τρέλα στις Μεθόδους μας {-}

Όταν μιλήσαμε για τις εμβέλειες, μιλήσαμε και για εκφράσεις block. Τότε όμως δεν τις είχαμε ονομάσει.
Ένα block δημιουργείται με αγκύλες (`{}`) και αξιολογεί όλες τις εκφράσεις μέσα σε αυτές, με το τελικό αποτέλεσμα να είναι αυτό της τελευταίας έκφρασης του.

```tut:book
// Αξιολογείται ως 3
{
  val one = 1
  val two = 2
  one + two
}
```

Μπορούμε να χρησιμοποιήσουμε εκφράσεις block ώστε να ερευνήσουμε την σειρά με την οποία αξιολογούνται οι παράμετροι μεθόδων, βάζοντας την έκφραση `println` μέσα σε ένα block το οποίο αξιολογείται με κάποια άλλη χρήσιμη τιμή.

Η χρήση για παράδειγμα του `Image.rectangle` ή του `Color.hsl` και οι εκφράσεις block, καθορίζουν το αν η Scala θα αξιολογήσει τις παραμέτρους της μεθόδου σε μία συγκεκριμένη σειρά και ποια θα είναι αυτή.

Σημειώστε ότι μπορείτε να γράψετε blocks μικρότερης έκτασης, χωρίζοντας τις εκφράσεις με ερωτηματικά (`;`).
Γενικά, αυτός δεν είναι καλός τρόπος αλλά μπορεί να φανεί χρήσιμος στα πειράματά μας.
Δείτε ένα παράδειγμα.

```tut:book
// Αξιολογείται ως 3
{ val one = 1; val two = 2; one + two }
```

<div class="solution">
Στο επόμενο παράδειγμα φαίνεται ότι οι παράμετροι μεθόδων αξιολογούνται από τα αριστερά προς τα δεξιά.

```tut:book
Color.hsl(
  {
    println("a")
    0.degrees
  },
  {
    println("b")
    1.normalized
  },
  { 
    println("c")
    1.normalized
  }
)
```

Μπορούμε να το γράψουμε εν συντομία όπως παρακάτω
```tut:book
Color.hsl({ println("a"); 0.degrees },
          { println("b"); 1.normalized },
          { println("c"); 1.normalized })
```
</div>


#### Η Τελευταία Σειρά  {-}

Με ποιά σειρά αξιολογούνται οι εκφράσεις στην Scala;
Κάντε δικά σας πειράματα ώστε να βρείτε την απάντηση που σας ικανοποιεί.
Μπορείτε να συμπεράνετε ότι η Scala εφαρμόζει τους ίδιους κανόνες για όλες τις εκφράσεις.
Δεν υπάρχουν ειδικές περιπτώσεις.

<div class="solution">
Έχουμε ήδη δει ότι οι εκφράσεις αξιολογούνται από πάνω προς τα κάτω και οι παράμετροι μεθόδων από τα αριστερά προς τα δεξιά.
Παρακάτω θα ελέγξουμε αν όλες οι εκφράσεις, αξιολογούνται από τα αριστερά προς τα δεξιά.
Αυτό μπορούμε να το δείξουμε αρκετά εύκολα.

```tut:book
{ println("a"); 1 } + { println("b"); 2 } + { println("c"); 3}
```

Το συμπέρασμα που προκείπτει είναι ότι οι εκφράσεις στην Scala αξιολογούνται από πάνω προς τα κάτω και από τα αριστερά προς τα δεξιά.
</div>

[^ειδικές-περιπτώσεις]: Αυτή δεν είναι όλη η αλήθεια. Υπάρχουν μερικές ειδικές περιπτώσεις στις οποίες η σειρά αξιολόγησης έχει σημασία ακόμη και στις pure εκφράσεις. Δεν θα ασχοληθούμε με αυτές τις περιπτώσεις. Εάν όμως θέλετε να μάθετε περισσότερα, μπορείτε να ψάξετε και να διαβάσετε για την "eager evaluation" και την "lazy evaluation".
