## Αντικατάσταση

Με την μέθοδο της αντικατάστασης, όπου βλέπουμε μία έκφραση μπορούμε να την αντικαταστήσουμε με την τιμή με την οποία αξιολογείται. Για παράδειγμα, όπου βλέπουμε

```tut:silent:book
1 + 1
```

μπορούμε να το αντικαταστήσουμε με το `2`.
Αυτό με τη σειρά του σημαίνει ότι όπου βλέπουμε μία σύνθετη έκφραση όπως

```tut:silent:book
(1 + 1) + (1 + 1)
```

μπορούμε να αντικαταστήσουμε το `1 + 1` με `2` και να πάρουμε

```tut:silent:book
2 + 2
```

που αξιολογείται με την τιμή `4`.

Αυτός ο τρόπος σκέψης, μας είναι γνωστός από την άλγεβρα του σχολείου αφού τον χρησιμοποιούσαμε για την απλοποίηση εκφράσεων.
Φυσικά, η επιστήμη των υπολογιστών έχει πιο φανταχτερές λέξεις γι' αυτή τη διαδικασία.
Εκτός από αντικατάσταση, μια άλλη ονομασία που χρησιμοποιείται είναι η *reducing an expression* (??απλοποίηση μία έκφρασης??), ή *equational reasoning* (??εξισωτική κάτι??).

Η αντικατάσταση μας δίνει τον τρόπο με τον οποίο μπορούμε να "καταλάβουμε τι κάνουν" τα προγράμματά μας.
Μπορούμε να εφαρμόσουμε την μέθοδο της αντικατάστασης σχεδόν σε όλες τις εκφράσεις που έχουμε δει μέχρι τώρα.
Σ΄αυτή την περίπτωση είναι πιο εύκολο να χρησιμοποιήσουμε παραδείγματα με αριθμούς και strings, παρά με εικόνες, οπότε θα επιστρέψουμε σε ένα παράδειγμα που είδαμε σε προηγούμενο κεφάλαιο:

```tut:silent:book
1 + ("Moonage daydream".indexOf("N"))
```

Το παραπάνω παράδειγμα το είχαμε προσπεράσει λίγο πρόχειρα.
Τώρα όμως θα δείξουμε τα βήματα που θα κάνει ο υπολογιστής, με μεγαλύτερη ακρίβεια.
Έτσι κι αλλιώς, αυτό που προσπαθούμε να κάνουμε είναι να τον μιμηθούμε.

Η έκφραση που περιέχει τον τελεστή `+` αποτελείται από δύο υπό-εκφράσεις, την`1` και την `("Moonage daydream".indexOf("N"))`.
Πρέπει να αποφασίσουμε πια θέλουμε να αξιολογήσουμε πρώτη: την δεξιά ή την αριστερή.
Ας διαλέξουμε αυθαίρετα την δεξιά υπό-έκφραση (θα επιστρέψουμε σ' αυτήν την επιλογή αργότερα ).

Η υπό-έκφραση `("Moonage daydream".indexOf("N"))` αποτελείται και αυτή από δύο υπό-εκφράσεις, την `"Moonage daydream"` και την `"N"`.
Ας αξιολογήσουμε και πάλι πρώτα την δεξιά, έχοντας στο μυαλό μας ότι οι κυριολεκτικές εκφράσεις δεν είναι τιμές και άρα πρέπει να αξιολογηθούν.

Η κυριολεκτική έκφραση `"N"` αξιολογείται με την τιμή `"N"`.
Για να αποφύγουμε την πιθανή σύγχυση, ας γράψουμε την τιμή ως `|"N"|`.
Τώρα μπορούμε να την αντικαταστήσουμε με την έκφραση, κάνοντας έτσι τα πρώτα μας βήματα

```scala
1 + ("Moonage daydream".indexOf(|"N"|))
```

Έπειτα, μπορούμε να αξιολογήσουμε την αριστερή πλευρά της υπό-έκφρασης, αντικαθιστώντας την κυριολεκτική έκφραση `"Moonage daydream"` με την τιμή της `|"Moonage daydream"|`.
Αυτό μας δίνει

```scala
1 + (|"Moonage daydream"|.indexOf(|"N"|))
```

Τώρα είμαστε σε θέση να αξιολογήσουμε ολόκληρη την έκφραση `(|"Moonage daydream"|.indexOf(|"N"|))`, η οποία αξιολογείται με `|-1|` (και πάλι, μπορείτε να ξεχωρίσετε την ακέραια τιμή από την κυριολεκτική έκφραση, από τις οριζόντιες γραμμές).
Εφαρμόζοντας ξανά την μέθοδο της αντικατάστασης έχουμε

```scala
1 + |-1|
```

Θα πρέπει να αξιολογήσουμε την αριστερή κυριολεκτική έκφραση `1`, που δίνει `|1|`.
Κάνοντας αντικατάσταση παίρνουμε

```scala
|1| + |-1|
```

Τώρα μπορούμε να αξιολογήσουμε ολόκληρη την έκφραση. Το αποτέλεσμα που θα πάρουμε είναι

```scala
|0|
```

Μπορούμε να ζητήσουμε από την Scala να αξιολογήσει ολόκληρη την έκφραση ώστε να ελέγξουμε την δουλειά μας.

```tut:book
1 + ("Moonage daydream".indexOf("N"))
```

Σωστό!

Σε αυτό το σημείο μπορούμε να κάνουμε κάποιες παρατηρήσεις:

 - αν κάνουμε την αντικατάσταση τόσο αυστηρά όσο ο υπολογιστής, μπορεί να χρειαστούν πολλά βήματα
 - ο πιο σύντομος υπολογισμός που ίσως κάνατε με το μυαλό σας, μάλλον σας οδήγησε στην σωστή απάντηση
 - η φαινομενικά αυθαίρετη επιλογή μας να αξιολογήσουμε από τα δεξιά προς τα αριστερά, μας οδήγησε στην σωστή απάντηση.

Μήπως με κάποιον τρόπο καταφέραμε να χρησιμοποιήσουμε την ίδια σειρά αξιολόγησης που χρησιμοποιεί και η Scala (όχι, δεν έγινε έτσι αλλά αυτό είναι κάτι που δεν έχουμε ερευνήσει ακόμα) ή δεν έχει όντως σημασία η σειρά που επιλέγουμε;
Πότε μπορούμε να κάνουμε συντομεύσεις και να πάρουμε το σωστό αποτέλεσμα, όπως κάναμε στο πρώτο παράδειγμα με την πρόσθεση;
Θα εξετάσουμε αυτές τις ερωτήσεις σε λίγο αλλά πρώτα ας μιλήσουμε για το πώς χρησιμοποιείται η μέθοδος της αντικατάστασης στα ονόματα.


### Ονόματα

Ο κανόνας για αντικατάσταση ονομάτων είναι να αντικαθίσταται το όνομα με την τιμή με την οποία αξιολογείται.
Ψωρίς να το ξέρουμε, τον έχουμε ήδη χρησιμοποιήσει αυτόν τον κανόνα.
Τώρα απλώς τον επισημοποιούμε.

Για παράδειγμα, με δεδομένο αυτόν τον κώδικα

```tut:silent:book
val name = "Ada"
name ++ " " ++ "Lovelace"
```

μπορούμε να εφαρμόσουμε την μέθοδο της αντικατάστασης ώστε να πάρουμε

```tut:silent:book
"Ada" ++ " " ++ "Lovelace"
```

που αξιολογείται ως

```tut:silent:book
"Ada Lovelace"
```

Για να γίνουμε λίγο πιο τυπικοί με την διαδικασία αντικαταστάσεων, μπορούμε να χρησιμοποιούμε ονόματα.
Ας επιστρέψουμε στο πρώτο μας παράδειγμα

```tut:silent:book
1 + 1
```

μπορούμε να δώσουμε ένα όνομα σ' αυτή την έκφραση:

```tut:silent:book
val two = 1 + 1
```

Όταν βλέπουμε μία σύνθετη έκφραση όπως η

```tut:silent:book
(1 + 1) + (1 + 1)
```

η μέθοδος της αντικατάστασης μας λέει ότι μπορούμε να αντικαταστήσουμε το `1 + 1` με το `two` ώστε να πάρουμε

```tut:silent:book
two + two
```

Θυμηθείτε ότι όταν εξετάσαμε την έκφραση

```tut:silent:book
1 + ("Moonage daydream".indexOf("N"))
```

αναγκαστήκαμε να την χωρίσουμε σε υπό-εκφράσεις, τις οποίες αξιολογήσαμε και στην συνέχεια αντικαταστήσαμε.
Αυτή η διαδικασία είναι αρκετά δυσνόητη.
Με την χρήση όμως μερικών δηλώσεων `val` μπορούμε να την συμπυκνώσουμε και να την κάνουμε πιο ευκολονόητη.
Παρακάτω μπορείτε να δείτε την ίδια αυτή έκφραση, διασπασμένη στα συστατικά της στοιχεία.

```tut:silent:book
val a = 1
val b = "Moonage daydream"
val c = "N"
val d = b.indexOf(c)
val e = a + d
```

Εάν ορίσουμε (αυθαίρετα σε αυτό το σημείο) ότι η αξιολόγηση γίνεται από πάνω προς τα κάτω, τότε μπορούμε να πειραματιστούμε με την σειρά των εντολών ώστε να δούμε ποιες θα είναι οι διαφορές στο αποτέλεσμα.

Για παράδειγμα, ο παρακάτω κώδικας

```tut:silent:book
val c = "N"
val b = "Moonage daydream"
val a = 1
val d = b.indexOf(c)
val e = a + d
```

δίνει το ίδιο αποτέλεσμα με πριν.
Όμως δεν μπορούμε να χρησιμοποιήσουμε το παρακάτω

```scala
val e = a + d
val a = 1
val b = "Moonage daydream"
val c = "N"
val d = b.indexOf(c)
```

αφού το `e` εξαρτάται από το `a` και το `d`, και με την από πάνω προς το κάτω σειρά που επιλέξαμε, τα `a` και `d` δεν έχουν αξιολογηθεί ακόμα.
Θα μπορούσαμε να ισχυριστούμε ότι είναι χαζό να το επιχειρήσουμε αλλά το `e` είναι η έκφραση που προσπαθούμε να αξιολογήσουμε και από το `a` μέχρι το `d` είναι υπό-εκφράσεις του `e`. Οπότε φυσικά πρέπει να αξιολογήσουμε πρώτα τις υπό-εκφράσεις πριν αξιολογήσουμε την έκφραση.
