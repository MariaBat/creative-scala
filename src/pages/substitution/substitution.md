## Αντικατάσταση (Substitution)

Με την μέθοδο της αντικατάστασης, όπου βλέπουμε μία έκφραση μπορούμε να την αντικαταστήσουμε με την τιμή με την οποία αξιολογείται. Για παράδειγμα, όπου βλέπουμε

```tut:silent:book
1 + 1
```

μπορούμε να το αντικαταστήσουμε με το `2`.
Αυτό με τη σειρά του σημαίνει ότι όπου βλέπουμε μία σύνθετη έκφραση όπως

```tut:silent:book
(1 + 1) + (1 + 1)
```

μπορούμε να αντικαταστήσουμε το `1 + 1` με `2` και να πάρουμε

```tut:silent:book
2 + 2
```

με αποτέλεσμα `4`.

Αυτόν τον τρόπο σκέψης χρησιμοποιούσαμε στην άλγεβρα του σχολείου όταν απλοποιούσαμε μία έκφραση.
Φυσικά η επιστήμη των υπολογιστών έχει πιο φανταχτερές λέξεις γι' αυτή τη διαδικασία.
Εκτός από αντικατάσταση, μπορούμε να ονομάσουμε αυτή τη διαδικασία και *reducing an expression* (??απλοποίηση μία έκφρασης??), ή *equational reasoning* (??).

Η αντικατάσταση μας δίνει έναν τρόπο ώστε να σκεφτούμε για τα προγράμματά μας, δηλαδή με άλλα
λόγια, να "κατανοήσουμε τον τρόπο με τον οποίο δουλεύουν".
Μπορούμε να εφαρμόσουμε την αντικατάσταση σχεδόν σε όλες τις εκφράσεις που έχουμε δει μέχρι τώρα.
Σ΄αυτή την περίπτωση είναι πιο εύκολο να χρησιμοποιήσουμε παραδείγματα με αριθμούς και strings, παρά με εικόνες, και έτσι θα επιστρέψουμε σε ένα παράδειγμα που είδαμε σε προηγούμενο κεφάλαιο:

```tut:silent:book
1 + ("Moonage daydream".indexOf("N"))
```

Το προηγούμενο παράδειγμα το είχαμε προσπεράσει λίγο πρόχειρα.
Τώρα όμως θα είμαστε πιο ακριβείς ώστε να δείξουμε τα βήματα που θα κάνει ο υπολογιστής μέχρι το τέλος.
Έτσι κι αλλιώς προσπαθούμε να μιμηθούμε τον υπολογιστή.

Η έκφραση που περιέχει το `+` αποτελείται από δύο υπό-εκφράσεις, την`1` και την `("Moonage daydream".indexOf("N"))`.
Πρέπει να αποφασίσουμε πια θέλουμε να αξιολογήσουμε πρώτη: την δεξιά ή την αριστερή.
Ας διαλέξουμε αυθαίρετα την δεξιά υπό-έκφραση (θα επιστρέψουμε αργότερα σ' αυτήν την επιλογή).

Για ακόμη μία φορά η υπό-έκφραση `("Moonage daydream".indexOf("N"))` αποτελείται από δύο υπό-εκφράσεις, την `"Moonage daydream"` και την `"N"`.
Ας αξιολογήσουμε και πάλι πρώτα την δεξιά, έχοντας στο μυαλό μας ότι οι κυριολεκτικές εκφράσεις δεν είναι τιμές και άρα δεν χρειάζεται να αξιολογηθούν.

Η κυριολεκτική έκφραση `"N"` αξιολογείται με την τιμή `"N"`.
Για να αποφύγουμε την σύγχυση ας γράψουμε την τιμή ως `|"N"|`.
Τώρα μπορούμε να αντικαταστήσουμε την τιμή με την έκφραση, κάνοντας έτσι τα πρώτα μας βήματα

```scala
1 + ("Moonage daydream".indexOf(|"N"|))
```

Τώρα μπορούμε να αξιολογήσουμε την αριστερή πλευρά της υπό-έκφρασης, αντικαθιστώντας την κυριολεκτική έκφραση `"Moonage daydream"` με την τιμή της `|"Moonage daydream"|`.
Αυτό μας δίνει

```scala
1 + (|"Moonage daydream"|.indexOf(|"N"|))
```

Τώρα είμαστε σε θέση να αξιολογήσουμε ολόκληρη την έκφραση `(|"Moonage daydream"|.indexOf(|"N"|))`, η οποία αξιολογείται με `|-1|` (για ακόμη μία φορά η ακέραια τιμή διαφοροποιείται από την κυριολεκτική έκφραση χρησιμοποιώντας τις οριζόντιες γραμμές).
Χρησιμοποιώντας και πάλι την αντικατάσταση έχουμε

```scala
1 + |-1|
```

Τώρα θα πρέπει να αξιολογήσουμε την αριστερή κυριολεκτική έκφραση `1`, που δίνει `|1|`.
Κάνοντας αντικατάσταση παίρνουμε

```scala
|1| + |-1|
```

Τώρα μπορούμε να αξιολογήσουμε ολόκληρη την έκφραση, παίρνοντας

```scala
|0|
```

Μπορούμε να ζητήσουμε από την Scala να αξιολογήσει ολόκληρη την έκφραση και να ελέγξουμε την δουλειά μας.

```tut:book
1 + ("Moonage daydream".indexOf("N"))
```

Σωστό!

Σε αυτό το σημείο μπορούμε να κάνουμε κάποιες παρατηρήσεις:

 - αν κάνουμε την αντικατάσταση τόσο αυστηρά όσο ο υπολογιστής, μπορεί να χρειαστούν πολλά βήματα,
 - η πιο σύντομη αξιολόγηση που ίσως κάνατε με το μυαλό σας, μάλλον σας οδήγησε στην σωστή απάντηση, και
 - η φαινομενικά αυθαίρετη επιλογή μας να αξιολογήσουμε από τα δεξιά προς τα αριστερά, μας οδήγησε στην σωστή απάντηση.

Μήπως με κάποιον τρόπο καταφέραμε να χρησιμοποιήσουμε την ίδια σειρά αξιολόγησης που χρησιμοποιεί και η Scala (όχι, δεν έγινε έτσι, αλλά δεν το έχουμε εξερευνήσει αυτό ακόμα) ή έχει όντως σημασία η σειρά με την οποία επιλέγουμε;
Πότε μπορούμε να κάνουμε συντομεύσεις και να πάρουμε το σωστό αποτέλεσμα, όπως κάναμε στο πρώτο παράδειγμα με την πρόσθεση;
Θα εξετάσουμε αυτές τις ερωτήσεις σε λίγο, αλλά πρώτα ας μιλήσουμε για το πώς δουλεύει η αντικατάσταση για τα ονόματα.


### Ονόματα

Ο κανόνας για αντικατάσταση ονομάτων είναι να αντικαθίσταται το όνομα με την τιμή στην οποία αξιολογείται.
Ασυνείδητα, τον έχουμε ήδη χρησιμοποιήσει αυτόν τον κανόνα.
Τώρα απλώς τον τυποποιούμε.

Για παράδειγμα, με δεδομένο αυτόν τον κώδικα

```tut:silent:book
val name = "Ada"
name ++ " " ++ "Lovelace"
```

μπορούμε να κάνουμε αντικατάσταση ώστε να πάρουμε

```tut:silent:book
"Ada" ++ " " ++ "Lovelace"
```

αυτό αξιολογείται σε

```tut:silent:book
"Ada Lovelace"
```

Μπορούμε να χρησιμοποιήσουμε ονόματα για να γίνουμε λίγο πιο τυπικοί με την διαδικασία αντικαταστάσεων.
Ας επιστρέψουμε στο πρώτο μας παράδειγμα

```tut:silent:book
1 + 1
```

μπορούμε να δώσουμε ένα όνομα σ' αυτή την έκφραση:

```tut:silent:book
val two = 1 + 1
```

Όταν βλέπουμε μία σύνθετη έκφραση όπως η

```tut:silent:book
(1 + 1) + (1 + 1)
```

η μέθοδος της αντικατάστασης μας λέει ότι μπορούμε να αντικαταστήσουμε το `1 + 1` με το `two` ώστε να πάρουμε

```tut:silent:book
two + two
```

Θυμηθείτε ότι όταν εξετάζουμε την έκφραση

```tut:silent:book
1 + ("Moonage daydream".indexOf("N"))
```

πρέπει να την χωρίσουμε σε υπό-εκφράσεις οι οποίες αξιολογούνται και αντικαθιστώνται.
Αυτή η περιγραφή με λέξεις φαίνεται αρκετά δυσνόητη.
Με την χρήση όμως μερικών δηλώσεων `val` μπορούμε να το συμπυκνώσουμε και να το κάνουμε πιο ευκολονόητο.
Η παρακάτω είναι η ίδια έκφραση, διασπασμένη στα συστατικά της στοιχεία.

```tut:silent:book
val a = 1
val b = "Moonage daydream"
val c = "N"
val d = b.indexOf(c)
val e = a + d
```

Εάν ορίσουμε (αυθαίρετα σε αυτό το σημείο) ότι η αξιολόγηση γίνεται από πάνω προς τα κάτω, τότε μπορούμε να πειραματιστούμε με διάφορες σειρές αντικατάστασης για να δούμε ποιες θα είναι οι διαφορές.

Για παράδειγμα,

```tut:silent:book
val c = "N"
val b = "Moonage daydream"
val a = 1
val d = b.indexOf(c)
val e = a + d
```

έτσι επιτυγχάνεται το ίδιο αποτέλεσμα όπως πριν.
Όμως δεν μπορούμε να χρησιμοποιήσουμε το παρακάτω

```scala
val e = a + d
val a = 1
val b = "Moonage daydream"
val c = "N"
val d = b.indexOf(c)
```

αφού το `e` εξαρτάται από το `a` και το `d`, και με την από πάνω προς το κάτω σειρά που επιλέξαμε, τα `a` και `d` δεν έχουν αξιολογηθεί ακόμα.
Θα μπορούσαμε να ισχυριστούμε ότι είναι χαζό ακόμη και να το επιχειρήσουμε, αλλά το `e` είναι ολόκληρη η έκφραση που προσπαθούμε να αξιολογήσουμε και από το `a` μέχρι το `d` είναι υπό-εκφράσεις του `e`, και φυσικά πρέπει να αξιολογήσουμε πρώτα τις υπό-εκφράσεις πριν αξιολογήσουμε την έκφραση.
