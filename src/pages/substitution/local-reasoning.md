## Τοπική Συλλογιστική

Έχουμε δει ότι η σειρά αξιολόγησης είναι πραγματικά σημαντική μόνο όταν υπάρχουν side effects.
Για παράδειγμα, αν οι επόμενες εκφράσεις δημιουργούν side effects

```scala
disableWarheads()
launchTheMissles()
```

τότε θα θέλουμε να σιγουρευτούμε ότι οι εκφράσεις αξιολογούνται από πάνω προς τα κάτω ώστε οι κεφαλές να αφοπλιστούν πριν την εκτόξευση των πυραύλων.

Όλα τα χρήσιμα προγράμματα πρέπει να έχουν κάποιο effect, αφού το πρόγραμμα χρησιμοποιεί τα effects για να επικοινωνήσει με τον έξω κόσμο.
Το effect μπορεί απλώς να εκτυπώνει κάτι όταν τελειώνει το πρόγραμμα, αλλά μετά παραμένει εκεί.
Η ελαχιστοποίηση των side effects αποτελεί έναν στόχο κλειδί για τον συναρτησιακό προγραμματισμό συνεπώς θα αφιερώσουμε λίγες ακόμη λέξεις σ' αυτό το θέμα.

Το μοντέλο της αντικατάστασης γίνεται κατανοητό πολύ εύκολα.
Όταν δεν έχει σημασία η σειρά αξιολόγησης σημαίνει ότι κανένας άλλος κώδικας δεν έχει την δυνατότητα να αλλάξει το νόημα του κώδικα που κοιτάμε.
Το `1 + 1` είναι πάντα `2`, και δεν έχει σημασία τι άλλο κώδικα έχουμε στο πρόγραμμά μας, όμως το effect του `launchTheMissles()` εξαρτάται από το αν έχουμε αφοπλίσει ήδη τις κεφαλές ή όχι.

Το αποτέλεσμα είναι ότι ο καθαρός κώδικας μπορεί να γίνει κατανοητός ακόμη και αποκομμένος.
Αφού κανένας άλλος κώδικας δεν μπορεί να αλλάξει το νόημά του, αν ενδιαφερόμαστε μόνο για ένα κομμάτι, μπορούμε να αγνοήσουμε τον υπόλοιπο κώδικα.
Από την άλλη, το νόημα του μη-καθαρού κώδικα, εξαρτάται από όλον τον κώδικα που έχει εκτελεστεί πριν από την δική του αξιολόγηση.
Αυτή η ιδιότητα είναι γνωστή ως *τοπική συλλογιστική* (local reasoning).
Ο καθαρός κώδικας την έχει, ενώ ο μη-καθαρός όχι.

Καθώς τα προγράμματα γίνονται όλο και μεγαλύτερα γίνεται δυσκολότερο να συγκρατήσουμε όλες τις λεπτομέρειες στο μυαλό μας.
Αφού το κεφάλι μας είναι μία στάνταρ ποσότητα (??προκαθορισμένη ποσότητα/χωρητικότητα??) η μόνη λύση είναι να εισάγουμε την έννοια της αφαιρετικότητας.
Θυμηθείτε ότι μία αφαίρεση είναι η απομάκρυνση ασήμαντων λεπτομερειών.
Ο καθαρός κώδικας είναι η απόλυτη αφαίρεση, αφού μας λέει ότι όλα τα υπόλοιπα είναι άσχετες λεπτομέρειες.
Αυτή είναι μία από τις ιδιότητες που κάνει τον συναρτησιακό προγραμματισμό συναρπαστικό: η ικανότητα να γίνονται κατανοητά τα μεγάλα προγράμματα.
Αυτό δεν σημαίνει ότι ο συναρτησιακός προγραμματισμός αποφεύγει τα effects, αφού όλα τα χρήσιμα προγράμματα έχουν effects.
Σημαίνει όμως, ότι η διαχείριση των effects γίνεται έτσι ώστε η πλειοψηφία του κώδικα να μπορεί να συμβαδίσει με την λογική του απλού μοντέλου της αντικατάστασης.


### Το Νόημα του Νοήματος

Παραπάνω μιλήσαμε αρκετά για το νόημα του κώδικα, θεωρώντας ότι το "νόημα" είναι το αποτέλεσμα με το οποίο αξιολογείται ο κώδικας και ίσως και τα side effects που περιλαμβάνει.

Με άλλα λόγια το νόημα, είναι ακριβώς αυτό με το οποίο αξιολογείται ο κώδικας.
Συνεπώς, δύο προγράμματα είναι ίσα αν αξιολογούνται με το ίδιο αποτέλεσμα.
Αυτός είναι και ο λόγος για τον οποίο όταν υπάρχουν side effects δεν μπορεί να γίνει αντικατάσταση: το μοντέλο της αντικατάστασης δεν έχει επίγνωση των side effects και άρα δεν μπορεί να ξεχωρίσει δύο προγράμματα με διαφορετικά αποτελέσματα.

Υπάρχουν και άλλοι τρόποι με τους οποίους μπορεί να διαφέρουν τα προγράμματα.
Για παράδειγμα, ένα πρόγραμμα μπορεί να χρειαστεί περισσότερο χρόνο από ένα άλλο για να φέρει το ίδιο αποτέλεσμα.
Και πάλι, το μοντέλο της αντικατάστασης δεν μπορεί να τα ξεχωρίσει.

Η αντικατάσταση είναι μία αφαίρεση, και οι λεπτομέρειες που απομακρύνει είναι τα πάντα εκτός από την τιμή.
Τα side effects, ο χρόνος και η χρήση της μνήμης είναι όλα ασήμαντα για την αντικατάσταση, αλλά ίσως δεν ισχύει το ίδιο και για τους ανθρώπους που φτιάχνουν ή εκτελούν το πρόγραμμα.
Εδώ γίνεται ένας συμβιβασμός.
Μπορούμε να χρησιμοποιήσουμε πιο πλούσια μοντέλα που κρατάν περισσότερες λεπτομέρειες, αλλά είναι πολύ πιο δύσκολα στην χρήση τους.
Για τους περισσότερους ανθρώπους την περισσότερη ώρα το μοντέλο της αντικατάστασης είναι ο κατάλληλος συμβιβασμός αφού είναι πολύ απλός και χρήσιμος.
