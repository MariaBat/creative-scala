## Local Reasoning (Τοπική Συλλογιστική :/)

Είδαμε ότι η σειρά αξιολόγησης είναι πραγματικά σημαντική μόνο όταν υπάρχουν side effects.
Για παράδειγμα, αν οι επόμενες εκφράσεις δημιουργούν side effects

```scala
disableWarheads()
launchTheMissles()
```

τότε θα πρέπει να σιγουρευτούμε ότι αξιολογούνται από πάνω προς τα κάτω ώστε οι κεφαλές να αφοπλιστούν πριν την εκτόξευση των πυραύλων.

Όλα τα χρήσιμα προγράμματα πρέπει να έχουν κάποιο effect, αφού έτσι αλληλεπιδρούν με τον έξω κόσμο.
Το effect μπορεί απλώς να εκτυπώνει κάτι όταν τελειώνει η εκτέλεση του προγράμματος αλλά δεν χάνεται και παραμένει εκεί.
Η ελαχιστοποίηση των side effects αποτελεί έναν στόχο κλειδί στον συναρτησιακό προγραμματισμό συνεπώς θα αφιερώσουμε λίγες ακόμη λέξεις σ' αυτό το θέμα.

Το μοντέλο της αντικατάστασης γίνεται πολύ εύκολα κατανοητό.
Όταν η σειρά αξιολόγησης δεν έχει σημασία, τότε κανένας άλλος κώδικας δεν έχει την δυνατότητα να αλλάξει το νόημα του κώδικα που κοιτάμε.
Η έκφραση `1 + 1` αξιολογείται πάντα με `2` και ο υπόλοιπος κώδικας του προγράμματός μας δεν μπορεί να το αλλάξει αυτό. Όμως το effect του `launchTheMissles()` εξαρτάται από το αν έχουμε αφοπλίσει ήδη τις κεφαλές ή όχι.

Αυτό έχει ως αποτέλεσμα, ο pure κώδικας να μπορεί να γίνει κατανοητός ακόμη και αποκομμένος από το υπόλοιπο πρόγραμμα.
Από την στιγμή που κανένας άλλος κώδικας δεν μπορεί να αλλάξει το νόημά του, αν ενδιαφερόμαστε μόνο για ένα κομμάτι, μπορούμε να αγνοήσουμε όλα τα υπόλοιπα.
Από την άλλη, το νόημα του impure κώδικα, εξαρτάται από όλον τον κώδικα που έχει εκτελεστεί πριν από την δική του αξιολόγηση.
Αυτή η ιδιότητα είναι γνωστή ως *local reasoning*.
Ο pure κώδικας την έχει ενώ ο impure όχι.

Καθώς τα προγράμματα γίνονται όλο και μεγαλύτερα γίνεται πιο δύσκολο για εμάς να συγκρατούμε όλες αυτές τις λεπτομέρειες στο μυαλό μας.
Επειδή το κεφάλι μας έχει συγκεκριμένη χωρητικότητα, η μόνη λύση είναι να εισάγουμε την έννοια της αφαιρετικότητας.
Θυμηθείτε ότι αυτή η μέθοδος είναι ουσιαστικά η απομάκρυνση ασήμαντων λεπτομερειών.
Ο pure κώδικας είναι η απόλυτη αφαίρεση, αφού μας λέει ότι όλα τα υπόλοιπα είναι άσχετες λεπτομέρειες.
Αυτή είναι μία από τις ιδιότητες που κάνει τον συναρτησιακό προγραμματισμό συναρπαστικό: η ικανότητα να γίνονται κατανοητά τα μεγάλα προγράμματα.
Αυτό δεν σημαίνει ότι ο συναρτησιακός προγραμματισμός αποφεύγει τα effects. Όλα τα χρήσιμα προγράμματα έχουν effects.
Σημαίνει όμως, ότι η διαχείριση τους γίνεται έτσι ώστε η πλειοψηφία του κώδικα να μπορεί να συμβαδίσει με την λογική του απλού μοντέλου της αντικατάστασης.


### Το Νόημα του Νοήματος

Παραπάνω μιλήσαμε αρκετά για το νόημα του κώδικα, υπονοώντας ότι το "νόημα" είναι το αποτέλεσμα με το οποίο αξιολογείται ο κώδικας και ίσως και τα side effects που περιλαμβάνει.

Με άλλα λόγια, το νόημα είναι αυτό με το οποίο αξιολογείται ο κώδικας.
Συνεπώς, δύο προγράμματα είναι ίσα αν αξιολογούνται με το ίδιο αποτέλεσμα.
Αυτός είναι και ο λόγος για τον οποίο όταν υπάρχουν side effects δεν μπορεί να γίνει αντικατάσταση: το μοντέλο της αντικατάστασης δεν έχει επίγνωση των side effects και άρα δεν μπορεί να ξεχωρίσει δύο προγράμματα με διαφορετικά αποτελέσματα. (??CHECK??)

Υπάρχουν και άλλοι τρόποι με τους οποίους μπορεί να διαφέρουν δύο προγράμματα.
Για παράδειγμα, ένα πρόγραμμα μπορεί να χρειαστεί περισσότερο χρόνο από ένα άλλο για να φέρει το ίδιο αποτέλεσμα.
Και πάλι, το μοντέλο της αντικατάστασης δεν μπορεί να τα ξεχωρίσει.

Η αντικατάσταση είναι μία αφαίρεση και οι λεπτομέρειες που απομακρύνει είναι τα πάντα εκτός από την τιμή.
Τα side effects, ο χρόνος και η χρήση της μνήμης, είναι όλα ασήμαντα για την αντικατάσταση αλλά ίσως δεν ισχύει το ίδιο και για τους ανθρώπους που φτιάχνουν ή εκτελούν το πρόγραμμα.
Εδώ γίνεται ένας συμβιβασμός.
Μπορούμε να χρησιμοποιήσουμε πιο πλούσια μοντέλα που κρατάν περισσότερες λεπτομέρειες αλλά είναι πολύ πιο δύσκολα στην χρήση τους.
Συνήθως, για τους περισσότερους ανθρώπους, το μοντέλο της αντικατάστασης είναι ο κατάλληλος συμβιβασμός αφού είναι πολύ απλός και χρήσιμος.
