# Σύνοψη

Σ' αυτό το βιβλίο καλύψαμε αρκετά από τα εργαλεία που χρησιμοποιούνται στον
συναρτησιακό προγραμματισμό και είναι διαθέσιμα στην Scala.

## Αναπαραστάσεις και Μεταφραστές

Ξεκινήσαμε γράφοντας εκφράσεις για να δημιουργήσουμε εικόνες.
Τα προγράμματα που γράψαμε πέρασαν από δύο διακριτές φάσεις:

 1. Σχεδίασαν μία εικόνα
 2. Κάλεσαν την μέθοδο `draw` για να την εμφανίσουν

Μέσα από αυτή τη διαδικασία παρατηρούμε δύο πολύ σημαντικά στοιχεία του συναρτησιακού προγραμματισμού:
την *κατασκευή ενδιάμεσων αναπαραστάσεων* του επιθυμητού αποτελέσματος
και την *μετάφραση αυτών των αναπαραστάσεων* ώστε να παράγουμε αποτέλεσμα.

## Αφαιρετικότητα

Η κατασκευή μίας ενδιάμεσης αναπαράστασης μας επιτρέπει
να μοντελοποιήσουμε πλευρές του αποτελέσματος που πιστεύουμε ότι είναι σημαντικές
και να χρησιμοποιήσουμε την έννοια της *αφαιρετικότητας* ώστε να απομακρύνουμε άσχετες λεπτομέρειες.

Για παράδειγμα, το Doodle αναπαριστά απευθείας τα βασικά σχήματα
και τις γεωμετρικές σχέσεις των σχεδίων μας
και έτσι δεν χρειάζεται να ανησυχούμε για τις λεπτομέρειες της υλοποίησης, όπως τις συντεταγμένες στην οθόνη.
Έτσι, ο κώδικάς μας παραμένει καθαρός, η τροποποίηση του εύκολη
και περιορίζονται οι "μαγικοί αριθμοί" που πρέπει να γράψουμε.
Για παράδειγμα, είναι πιο εύκολο να καταλάβουμε ότι ο παρακάτω κώδικας στο
Doodle θα παράγει ένα σπίτι:

~~~ scala
def myImage: Image =
  Triangle(50, 50) above Rectangle(50, 50)
// myImage: Image = // ...
~~~

από ότι αυτός ο κώδικας σε Java2D:

~~~ scala
def drawImage(g: Graphics2D): Unit = {
  g.setStroke(new BasicStroke(1.0f))
  g.setPaint(new Color(0, 0, 0))
  val path = new Path2D.Double()
  path.moveTo(25, 0)
  path.lineTo(50, 50)
  path.lineTo(0, 50)
  path.lineTo(25, 0)
  path.closePath()
  g.draw(path)
  f.drawRect(50, 50, 50, 50)
}
~~~

Είναι σημαντικό να κατανοήσετε ότι ο βασικός σε Java2D
βρίσκεται μέσα στο Doodle.
Η διαφορά είναι ότι τον έχουμε κρύψει μέσα στην μέθοδο `draw`.
Η `draw` έχει τον ρόλο του *μεταφραστή* για τις εικόνες μας,
συμπληρώνοντας όλες τις λεπτομέρειες σχετικά με τις συντεταγμένες, τα μονοπάτια
και τα γραφικά που δεν θέλουμε να σκεφτόμαστε καθώς γράφουμε τον κώδικά μας.

Ξεχωρίζοντας την τιμή από τον μεταφραστή,
έχουμε την δυνατότητα να αλλάξουμε τον τρόπο που γίνεται η μετάφραση.
Το Doodle έχει ήδη δύο μεταφραστές.
Ο ένας από αυτούς σχεδιάζει στην δομή της Java2D
ενώ ο άλλος στον καμβά της HTML.
Θα μπορούσε να φανταστεί κανείς μεταφραστές και για άλλες χρήσεις, όπως για παράδειγμα
έναν για σχεδιασμό εικόνων που φαίνονται σαν ζωγραφισμένες με το χέρι.

## Σύνθεση

Εκτός από το να κρατάμε τα προγράμματά μας καθαρά,
η συναρτησιακή προσέγγιση που έχει προτιμήσει το Doodle,
μας επιτρέπει να *συνθέσουμε* εικόνες χρησιμοποιώντας προϋπάρχουσες.
Για παράδειγμα, μπορούμε να επαναχρησιμοποιήσουμε τον κώδικα για το σπίτι ώστε να ζωγραφίσουμε έναν δρόμο:

~~~ scala
val house = Triangle(50, 50) above Rectangle(50, 50)
// house: Image = // ...

val street = house beside house beside house
// street: Image = // ...
~~~

Οι τιμές που δημιουργούμε για τις εικόνες και τα χρώματα είναι αμετάβλητες.
Μπορούμε εύκολα να χρησιμοποιήσουμε ένα σπίτι τρεις φορές μέσα στην ίδια εικόνα.

Αυτή η προσέγγιση, μας επιτρέπει να χωρίσουμε μία σύνθετη εικόνα σε μικρότερα κομμάτια
που μπορούμε να συνδυάσουμε μεταξύ τους, ώστε να δημιουργήσουμε το επιθυμητό αποτέλεσμα.

Η επαναχρησιμοποίηση αμετάβλητων δεδομένων, τεχνική που ονομάζεται *structure sharing*,
είναι η βάση πολλών γρήγορων και αποτελεσματικών, σε σχέση με την μνήμη, αμετάβλητων δομών δεδομένων.
Ένα πολύ αντιπροσωπευτικό παράδειγμα είναι το τρίγωνο Sierpinski
στο οποίο χρησιμοποιήσαμε μόνο ένα αντικείμενο `Triangle` για να δημιουργήσουμε μία εικόνα
η οποία περιλαμβάνει περίπου 20,000 χρωματιστά τρίγωνα.

## Προγραμματισμός Προσανατολισμένος σε Εκφράσεις

Η Scala μας παρέχει ένα πολύ βολικό συντακτικό για απλοποίηση
της δημιουργίας δομών δεδομένων με συναρτησιακό τρόπο.
Κατασκευές όπως οι δομές υπόθεσης (πχ if), οι βρόγχοι και τα blocks, είναι *εκφράσεις*,
που μας επιτρέπουν να γράφουμε μικρές μεθόδους, χωρίς
να πρέπει να δηλώσουμε πολλές ενδιάμεσες μεταβλητές.
Έτσι υιοθετούμε την συνήθεια να γράφουμε μικρές μεθόδους
των οποίων ο σκοπός είναι να επιστρέψουν μία τιμή.

## Τύποι και Δίχτυ Ασφαλείας

Το σύστημα τύπων της Scala μας βοηθάει να ελέγξουμε το προγράμμά μας.
Κάθε έκφραση έχει έναν τύπο ο οποίος ελέγχεται κατά την μεταγλώττιση,
ώστε να γίνει σίγουρο ότι ταιριάζει με τον υπόλοιπο κώδικα.
Μπορούμε ακόμη και να ορίσουμε τους δικούς μας τύπους, με μοναδικό σκοπό
να προστατέψουμε τον εαυτό μας από λάθη που μπορεί να κάνουμε.

Ένα πολύ απλό παράδειγμα είναι ο τύπος `Angle` του Doodle,
ο οποίος μας αποτρέπει από το να μπερδέψουμε τους αριθμούς, τις γωνίες,
τις μοίρες και τα ακτίνια:

~~~ scala
90
// res0: Int = 90

90.degrees
// res1: doodle.core.Angle = Angle(1.5707963267948966)

90.radians
// res2: doodle.core.Angle = Angle(2.0354056994857643)

90.degrees + 90.radians
// res3: doodle.core.Angle = Angle(3.606202026280661)

90 + 90.degrees
// <console>:20: error: overloaded method value + with alternatives:
//   (x: Double)Double <and>
//   (x: Float)Float <and>
//   (x: Long)Long <and>
//   (x: Int)Int <and>
//   (x: Char)Int <and>
//   (x: Short)Int <and>
//   (x: Byte)Int <and>
//   (x: String)String
// δεν μπορεί να εφαρμοστεί στο (doodle.core.Angle)
//              90 + 90.degrees
//                 ^
~~~

## Οι Συναρτήσεις ως Τιμές

Καθώς προγραμματίζουμε, ξοδεύουμε πολύ χρόνο στο να γράφουμε μεθόδους που παράγουν τιμές.
Οι μέθοδοι μας επιτρέπουν να χρησιμοποιήσουμε την έννοια της αφαιρετικότητας, όσον αφορά τις παραμέτρους.
Για παράδειγμα, η παρακάτω μέθοδος χρησιμοποιεί αυτήν την έννοια
για να σχεδιάσει κουκκίδες διαφορετικού χρώματος:

~~~ scala
def dot(color: Color): Image =
  Circle(10) lineWidth 0 fillColor color
// dot: Color => Image = // ...
~~~

Προερχόμενες από αντικειμενοστραφείς γλώσσες,
οι μέθοδοι δεν είναι κάτι ιδιαίτερο.
Η ικανότητα της Scala να μετατρέπει μεθόδους σε *συναρτήσεις*
που μπορούν να περαστούν ως τιμές, είναι πολύ πιο ενδιαφέρουσα. Δείτε παρακάτω:

~~~ scala
def spectrum(shape: Color => Image): Image =
  shape(Color.red) beside shape(Color.blue) beside shape(Color.green)
// spectrum: (Color => Image) => Image = // ...

spectrum(dot)
// res0: Image = // ...
~~~

Γράψαμε πολλά προγράμματα που χρησιμοποιούν συναρτήσεις ως τιμές
αλλά το πιο αντιπροσωπευτικό παράδειγμα ήταν η μέθοδος `map` στις λίστες.
Στο [κεφάλαιο "Συλλογές"](#collections) είδαμε πώς
η `map` μας επιτρέπει να μετασχηματίσουμε τις ακολουθίες χωρίς να μεταφέρουμε ή να "εισάγουμε" νέες τιμές
σε ενδιάμεσους buffers (μνήμες):

~~~ scala
List(1, 2, 3).map(x => x * 2)
// res0: List[Int] = List(2, 4, 6)
~~~

Οι συναρτήσεις και ο ορισμούς τους ως τιμές πρώτης τάξης,
είναι πολύ σημαντικά στοιχεία για την γραφή απλού και κατανοητού κώδικα.

## Επίλογος

Ο σκοπός αυτού του βιβλίου ήταν να σας συστήσει
τα κομμάτια της Scala που έχουν να κάνουν με τον συναρτησιακό προγραμματισμό.
Αυτά είναι που διαφοροποιούν την Scala από
παλαιότερες εμπορικές γλώσσες όπως η Java και η C.
Όμως αυτό είναι μόνο ένα μέρος της ιστορίας της Scala.
Πολλές σύγχρονες γλώσσες όπως η Ruby, η Python, η Javascript, και η Clojure
υποστηρίζουν τον συναρτησιακό προγραμματισμό.
Πώς σχετίζεται η Scala μ' αυτές τις γλώσσες
και γιατί να την προτιμήσετε έναντι των άλλων;

Ίσως το πιο σημαντικό πλεονέκτημα της Scala είναι το αυστηρό σύστημα τύπων που διαθέτει.
Αυτό διαφοροποιεί την Scala από άλλες δημοφιλείς γλώσσες
όπως η Ruby, η Python, η Javascript και η Clojure, οι οποίες διαθέτουν δυναμικό σύστημα τύπων.
Η χρήση στατικών τύπων είναι ένας αναγκαίος συμβιβασμός---η σύνταξη του κώδικα είναι
πιο αργή αφού πρέπει να ικανοποιεί τον μεταγλωττιστή σε όλα τα στάδια.
Όμως, αφού μεταγλωττιστεί ο κώδικάς μας μπορούμε να
είμαστε βέβαιοι για την ποιότητά του.

Άλλο ένα μεγάλο πλεονέκτημα της Scala είναι η ανάμειξη των
τεχνικών αντικειμενοστραφούς και συναρτησιακού προγραμματισμού.
Αυτό το είδαμε στο πρώτο κεφάλαιο---κάθε τιμή είναι ένα αντικείμενο
με μεθόδους, πεδία και μία κλάση (τύπο).
Παρόλα αυτά, σ' αυτό το βιβλίο δεν δημιουργήσαμε δικούς μας τύπους δεδομένων.
Η δημιουργία τύπων είναι συνώνυμο της δήλωσης κλάσεων
και η Scala υποστηρίζει μία μεγάλη ποικιλία τέτοιων χαρακτηριστικών
όπως για παράδειγμα, τις κλάσεις, τα traits, την κληρονομικότητα και τα generics.

Τέλος, μία σημαντική ικανότητα της Scala είναι η συμβατότητά της με την Java.
Η Scala θα μπορούσε να θεωρηθεί υπερσύνολο της Java
και η σχέση τους είναι αρκετά εμφανής.
Έτσι ανοίγεται ένας ολόκληρος κόσμος από βιβλιοθήκες της Java που μπορούν να χρησιμοποιηθούν από εφαρμογές της Scala.
Η μετάφραση εφαρμογών Java σε Scala είναι πολύ εύκολη.

## Επόμενα Βήματα

Ελπίζουμε να σας άρεσε η Creative Scala και ο σχεδιασμός εικόνων με το Doodle.
Αν θέλετε να μάθετε περισσότερα για αυτή,
θα προτείναμε να επιλέξετε ένα από τα υπέροχα βιβλία που είναι διαθέσιμα γι' αυτή τη γλώσσα.

Το δικό μας βιβλίο, [Essential Scala][essential-scala], είναι διαθέσιμο στην ιστοσελίδα μας
και συνεχίζει την προσέγγιση της Creative Scala σε σχέση με τον τρόπο εκμάθησης Scala,
συζητώντας και παρουσιάζοντας εικόνες.

Αν θέλετε να δυσκολέψετε τον εαυτό σας,
προσπαθήστε να ζωγραφίσετε κάτι πιο περίπλοκο με το Doodle και
μοιραστείτε το μαζί μας μέσω του [Gitter][underscore-gitter].
Υπάρχουν πολλά που μπορείτε να δοκιμάσετε---δείτε τον κατάλογο `examples`
στο Doodle για προτάσεις:

![Τρίγωνο Koch (Koch.scala)](src/pages/summary/koch.png)

![Αστικό τοπίο (Street.scala)](src/pages/summary/street.png)

![Mandelbrot Fractal του Mat Moore (Mandelbrot.scala)](src/pages/summary/mandelbrot.png)
