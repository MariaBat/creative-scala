# Σύνοψη

Σ' αυτό το βιβλίο καλύψαμε αρκετά από τα εργαλεία που χρησιμοποιούνται στον
συναρτησιακό προγραμματισμό και είναι διαθέσιμα στην Scala.

## Αναπαραστάσεις και Μεταφραστές

Ξεκινήσαμε γράφοντας εκφράσεις για να καταφέρουμε να δημιουργήσουμε εικόνες.
Όλα τα προγράμματα που γράψαμε πέρασαν από δύο διακριτές φάσεις:

 1. Δημιούργησαν μία εικόνα
 2. Κάλεσαν την μέθοδο `draw` για να την εμφανίσουν

Μέσα από αυτή τη διαδικασία μπορούμε να δούμε δύο πολύ σημαντικά στοιχεία του συναρτησιακού προγραμματισμού:
την *κατασκευή ενδιάμεσων αναπαραστάσεων* του επιθυμητού αποτελέσματος
και την *μετάφραση αυτών των αναπαραστάσεων* ώστε να παράγουμε αποτέλεσμα.

## Αφαιρετικότητα

Η κατασκευή μίας ενδιάμεσης αναπαράστασης μας επιτρέπει
να μοντελοποιήσουμε πλευρές του αποτελέσματος που πιστεύουμε ότι είναι σημαντικές
και να χρησιμοποιήσουμε την έννοια της *αφαιρετικότητας* ώστε να απομακρύνουμε άσχετες λεπτομέρειες.

Για παράδειγμα, το Doodle αναπαριστά απευθείας τα βασικά σχήματα
και τις γεωμετρικές σχέσεις των σχεδίων μας
και έτσι δεν χρειάζεται να ανησυχούμε για τις λεπτομέρειες της υλοποίησης όπως για τις συντεταγμένες της οθόνης.
Έτσι ο κώδικάς μας παραμένει καθαρός, η τροποποίηση του εύκολη,
και περιορίζονται και οι "μαγικοί αριθμοί" που πρέπει να γράψουμε.
Για παράδειγμα, είναι πιο εύκολο να καταλάβουμε ότι ο παρακάτω κώδικας στο
Doodle θα παράγει ένα σπίτι:

~~~ scala
def myImage: Image =
  Triangle(50, 50) above Rectangle(50, 50)
// myImage: Image = // ...
~~~

από ότι αυτός ο κώδικας σε Java2D:

~~~ scala
def drawImage(g: Graphics2D): Unit = {
  g.setStroke(new BasicStroke(1.0f))
  g.setPaint(new Color(0, 0, 0))
  val path = new Path2D.Double()
  path.moveTo(25, 0)
  path.lineTo(50, 50)
  path.lineTo(0, 50)
  path.lineTo(25, 0)
  path.closePath()
  g.draw(path)
  f.drawRect(50, 50, 50, 50)
}
~~~

Είναι πολύ σημαντικό να κατανοήσετε ότι όλος ο βασικός κώδικας σε Java2D
βρίσκεται μέσα στο Doodle.
Η διαφορά είναι ότι τον έχουμε κρύψει μέσα στην μέθοδο `draw`.
Η `draw` έχει τον ρόλο του *μεταφραστή* για τις εικόνες μας,
συμπληρώνοντας όλες τις λεπτομέρειες σχετικά με συντεταγμένες, μονοπάτια
και γραφικά που δεν θέλουμε να έχουμε στο μυαλό μας καθώς γράφουμε τον κώδικά μας.

Ξεχωρίζοντας την άμεση τιμή και τον μεταφραστή,
έχουμε την δυνατότητα να αλλάξουμε τον τρόπο που γίνεται η μετάφραση.
Το Doodle έχει ήδη δύο μεταφραστές.
Ο ένας από αυτούς σχεδιάζει στην δομή της Java2D
ενώ ο άλλος στον καμβά της HTML.
Θα μπορούσε να φανταστεί κανείς μεταφραστές και για άλλες χρήσεις, όπως για παράδειγμα
έναν για σχεδιασμό εικόνων που φαίνονται σαν ζωγραφισμένες με το χέρι.

## Σύνθεση

Εκτός από το να κρατάμε τα προγράμματά μας καθαρά,
η συναρτησιακή προσέγγιση που έχει προτιμήσει το Doodle,
μας επιτρέπει να *συνθέτουμε* εικόνες χρησιμοποιώντας άλλες εικόνες.
Για παράδειγμα, μπορούμε να επαναχρησιμοποιήσουμε τον κώδικα για το σπίτι ώστε να ζωγραφίσουμε έναν δρόμο:

~~~ scala
val house = Triangle(50, 50) above Rectangle(50, 50)
// house: Image = // ...

val street = house beside house beside house
// street: Image = // ...
~~~

Οι τιμές που δημιουργούμε για τις εικόνες και τα χρώματα είναι αμετάβλητες
και άρα μπορούμε εύκολα να χρησιμοποιήσουμε ένα σπίτι τρεις φορές μέσα στην ίδια εικόνα.

Αυτή η προσέγγιση μας επιτρέπει να χωρίσουμε μία σύνθετη εικόνα σε μικρότερα κομμάτια
που μπορούμε να τα συνδυάσουμε μεταξύ τους ώστε να δημιουργήσουμε το επιθυμητό αποτέλεσμα.

Η επαναχρησιμοποίηση αμετάβλητων δεδομένων, τεχνική που ονομάζεται *structure sharing*,
είναι η βάση πολλών γρήγορων και αποτελεσματικών, σε σχέση με την μνήμη, αμετάβλητων δομών δεδομένων.
Ένα πολύ αντιπροσωπευτικό παράδειγμα στο Doodle είναι το τρίγωνο Sierpinski
όπου χρησιμοποιήσαμε ένα μόνο αντικείμενο `Triangle` ώστε να δημιουργήσουμε μία εικόνα
η οποία συμπεριλαμβάνει περίπου 20,000 χρωματιστά τρίγωνα.

## Προγραμματισμός Προσανατολισμένος σε Εκφράσεις

Η Scala μας παρέχει ένα πολύ βολικό συντακτικό για απλοποίηση
της δημιουργίας δομών δεδομένων με συναρτησιακό τρόπο.
Κατασκευές όπως οι δομές υπόθεσης (πχ if), οι βρόγχοι και τα blocks, είναι *εκφράσεις*,
που μας επιτρέπουν να γράφουμε μικρές μεθόδους χωρίς
να πρέπει να δηλώσουμε πολλές ενδιάμεσες μεταβλητές.
Έτσι πολύ γρήγορα υιοθετούμε την συνήθεια να γράφουμε μικρές μεθόδους
των οποίων ο σκοπός είναι να επιστρέψουν μία τιμή,
καθιστώντας έτσι την λέξη-κλειδί `return` πολύ σημαντική.

## Τύποι και Δίχτυ Ασφαλείας

Το σύστημα τύπων της Scala μας βοηθάει στον έλεγχο του προγράμματός μας.
Κάθε έκφραση έχει έναν τύπο ο οποίος ελέγχεται κατά την μεταγλώττιση
ώστε να γίνει σίγουρο ότι ταιριάζει με τον υπόλοιπο κώδικα.
Μπορούμε ακόμη και να ορίσουμε τους δικούς μας τύπους με μοναδικό σκοπό
να προστατέψουμε τον εαυτό μας από λάθη που μπορεί να κάνουμε.

Ένα πολύ απλό παράδειγμα είναι ο τύπος `Angle` του Doodle,
ο οποίος μας αποτρέπει από το να μπερδέψουμε τους αριθμούς, τις γωνίες,
τις μοίρες και τα ακτίνια:

~~~ scala
90
// res0: Int = 90

90.degrees
// res1: doodle.core.Angle = Angle(1.5707963267948966)

90.radians
// res2: doodle.core.Angle = Angle(2.0354056994857643)

90.degrees + 90.radians
// res3: doodle.core.Angle = Angle(3.606202026280661)

90 + 90.degrees
// <console>:20: error: overloaded method value + with alternatives:
//   (x: Double)Double <and>
//   (x: Float)Float <and>
//   (x: Long)Long <and>
//   (x: Int)Int <and>
//   (x: Char)Int <and>
//   (x: Short)Int <and>
//   (x: Byte)Int <and>
//   (x: String)String
// δεν μπορεί να εφαρμοστεί στο (doodle.core.Angle)
//              90 + 90.degrees
//                 ^
~~~

## Οι Συναρτήσεις ως Τιμές

Καθώς προγραμματίζουμε ξοδεύουμε πολύ χρόνο στο να γράφουμε μεθόδους που παράγουν τιμές.
Οι μέθοδοι μας επιτρέπουν να χρησιμοποιήσουμε την έννοια της αφαιρετικότητας όσον αφορά τις παραμέτρους.
Για παράδειγμα, η παρακάτω μέθοδος χρησιμοποιεί την παραπάνω έννοια στα χρώματα
ώστε να παραχθούν κουκκίδες διαφορετικού χρώματος:

~~~ scala
def dot(color: Color): Image =
  Circle(10) lineWidth 0 fillColor color
// dot: Color => Image = // ...
~~~

Προερχόμενες από αντικειμενοστραφείς γλώσσες,
οι μέθοδοι δεν είναι κάτι ιδιαίτερο.
Η ικανότητα της Scala να μετατρέπει μεθόδους σε *συναρτήσεις*
που μπορούν να περαστούν ως τιμές, είναι πολύ πιο ενδιαφέρουσα. Δείτε παρακάτω:

~~~ scala
def spectrum(shape: Color => Image): Image =
  shape(Color.red) beside shape(Color.blue) beside shape(Color.green)
// spectrum: (Color => Image) => Image = // ...

spectrum(dot)
// res0: Image = // ...
~~~

Γράψαμε πολλά προγράμματα που χρησιμοποιούσαν συναρτήσεις ως τιμές
αλλά το πιο αντιπροσωπευτικό παράδειγμα ήταν η μέθοδος `map` των λιστών.
Στο [κεφάλαιο "Συλλογές"](#collections) είδαμε πώς
η `map` μας επιτρέπει να μετασχηματίσουμε τις ακολουθία χωρίς να μεταφέρουμε ή να "εισάγουμε" νέες τιμές
σε ενδιάμεσους buffers (μνήμες):

~~~ scala
List(1, 2, 3).map(x => x * 2)
// res0: List[Int] = List(2, 4, 6)
~~~

Οι συναρτήσεις και ο ορισμούς τους ως τιμές πρώτης τάξης,
είναι πολύ σημαντικά στοιχεία για την γραφή απλού και κατανοητού κώδικα.

## Επίλογος

Ο σκοπός αυτού του βιβλίου ήταν να σας συστήσει
τα κομμάτια της Scala που έχουν να κάνουν με τον συναρτησιακό προγραμματισμό.
Αυτά είναι που διαφοροποιούν την Scala από
άλλες παλαιότερες εμπορικές γλώσσες όπως η Java και η C.
Όμως αυτό είναι μόνο ένα μέρος της ιστορίας της Scala.
Πολλές σύγχρονες γλώσσες όπως η Ruby, η Python, η Javascript, και η Clojure
υποστηρίζουν και αυτές τον συναρτησιακό προγραμματισμό.
Πώς σχετίζεται η Scala μ' αυτές τις γλώσσες
και γιατί να την προτιμήσετε αντί για τις άλλες
δυνατές επιλογές;

Ίσως το πιο σημαντικό πλεονέκτημα της Scala είναι το σύστημα τύπων που διαθέτει.
Αυτό διαφοροποιεί την Scala από άλλες δημοφιλείς γλώσσες
όπως η Ruby, η Python, η Javascript και η Clojure, οι οποίες γράφονται δυναμικά.
Η χρήση στατικών τύπων είναι ένας αναγκαίος συμβιβασμός---η σύνταξη του κώδικα είναι
πιο αργή αφού πρέπει να ικανοποιεί τον μεταγλωττιστή σε όλα τα στάδια.
Όμως, αφού μεταγλωττιστεί ο κώδικάς μας τότε μπορούμε να
είμαστε βέβαιοι για την ποιότητά του.

Άλλο ένα μεγάλο πλεονέκτημα της Scala είναι η ανάμειξη των
τεχνικών αντικειμενοστραφούς και συναρτησιακού προγραμματισμού.
Αυτό το είδαμε στο πρώτο κεφάλαιο---κάθε τιμή είναι αντικείμενο
με μεθόδους, πεδία και μία κλάση (τύπο).
Παρόλα αυτά, σ' αυτό το βιβλίο δεν δημιουργήσαμε δικούς μας τύπους δεδομένων.
Η δημιουργία τύπων είναι συνώνυμο της δήλωσης κλάσεων
και η Scala υποστηρίζει μία μεγάλη ποικιλία τέτοιων στοιχείων
όπως για παράδειγμα, τις κλάσεις, τους τύπους, την κληρονομικότητα και την ικανότητα περάσματος τύπων παραμέτρων.

Τέλος, μία σημαντική ικανότητα της Scala είναι η συμβατότητά της με την Java.
Η Scala θα μπορούσε να θεωρηθεί υπερσύνολο της Java,
και η σύνδεσή τους είναι αρκετά εμφανής.
Έτσι ανοίγεται ένας ολόκληρος κόσμος βιβλιοθηκών Java που μπορούν να χρησιμοποιήσουν οι εφαρμογές σε Scala
και συνεπώς η μετάφραση εφαρμογών Java σε Scala γίνεται πολύ εύκολη.

## Επόμενα Βήματα

Ελπίζουμε να σας άρεσε η Creative Scala και ο σχεδιασμός εικόνων με το Doodle.
Αν θέλετε να μάθετε περισσότερα για αυτή,
θα προτείναμε να επιλέξετε ένα από τα πολλά υπέροχα βιβλία που είναι διαθέσιμα γι' αυτή τη γλώσσα.

Το δικό μας βιβλίο, [Essential Scala][essential-scala], είναι διαθέσιμο στην ιστοσελίδα μας
και συνεχίζει την προσέγγιση της Creative Scala σε σχέση με τον τρόπο εκμάθησης Scala
συζητώντας και παρουσιάζοντας εικόνες.

Αν θέλετε να δυσκολέψετε τον εαυτό σας,
προσπαθήστε να ζωγραφίσετε κάτι πιο περίπλοκο με το Doodle και
μοιραστείτε το μαζί μας μέσω του [Gitter][underscore-gitter].
Υπάρχουν πολλά που μπορείτε να δοκιμάσετε---δείτε τον κατάλογο `examples`
στο Doodle για προτάσεις:

![Τρίγωνο Koch (Koch.scala)](src/pages/summary/koch.png)

![Αστικό τοπίο (Street.scala)](src/pages/summary/street.png)

![Mandelbrot Fractal του Mat Moore (Mandelbrot.scala)](src/pages/summary/mandelbrot.png)
