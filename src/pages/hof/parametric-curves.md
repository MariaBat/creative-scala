## Παραμετρικές Καμπύλες

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Μέχρι τώρα, ξέρουμε μόνο πώς να φτιάχνουμε βασικά σχήματα όπως κύκλους και ορθογώνια.
Ο σκοπός μας είναι να σχεδιάσουμε λουλούδια αλλά για να το κάνουμε αυτό θα χρειαστούμε περισσότερα εργαλεία.
Γι' αυτο, θα χρησιμοποιήσουμε ένα μαθηματικό εργαλείο γνωστό ως *παραμετρική εξίσωση* ή *παραμετρική καμπύλη*.

Μία παραμετρική εξίσωση είναι μία συνάρτηση που δέχεται μία είσοδο (παράμετρος) και επιστρέφει ένα σημείο (τοποθεσία στον χώρο).
Για παράδειγμα, η παραμετρική εξίσωση ενός κύκλου είναι μία συνάρτηση που δέχεται μία `Angle` (γωνία) και επιστρέφει ένα σημείο.

```scala
def parametricCircle(angle: Angle): Point =
  ???
```

Μπορούμε να κατασκευάσουμε μικρές κουκκίδες ή άλλα σχήματα σ' αυτά τα σημεία και έτσι να δημιουργήσουμε μεγάλα σχήματα όπως αυτά που θέλουμε να ζωγραφίσουμε.

Στην εικόνα [@fig:hof:parametric-circles] μπορείτε να δείτε ένα παράδειγμα μικρών κύκλων που έχουν δημιουργηθεί με την παραμετρική εξίσωση κύκλου.
Πηγαίνοντας από τα αριστερά προς τα δεξιά, ζωγραφίζουμε σημεία κάθε 90, 45, και 22.5 μοίρες.
Μπορείτε να δείτε το περίγραμμα του σχήματος να γίνεται όλο και πιο έντονο καθώς ζωγραφίζουμε περισσότερα σημεία.

![Παραμετρικός κύκλος που δημιουργείται από τα αριστερά προς τα δεξιά με σημεία σε κάθε 90, 45, και 22.5 μοίρες.](src/pages/hof/parametric-circles.pdf+svg){#fig:hof:parametric-circles}

Για να δημιουργήσουμε παραμετρικές καμπύλες πρέπει να μάθουμε πώς να φτιάχνουμε σημεία με το Doodle, πώς να εμφανίζουμε εικόνες σε συγκεκριμένο σημείο στον χώρο και να θυμηθούμε λίγη γεωμετρία γυμνασίου.


## Σημεία

Στο Doodle, για αναπαράσταση μίας θέσης σε δισδιάστατο χώρο, υπάρχει ο τύπος `Point`. Έχουμε στην διάθεσή μας δύο ισοδύναμες αναπαραστάσεις:

- οι συντεταγμένες x και y, δηλαδή το καρτεσιανό σύστημα αναπαράστασης συντεταγμένων, και
- η αναπαράσταση με πολικές συντεταγμένες όπου χρησιμοποιείται μία γωνία και η απόστασή της από ένα αρχικό σημείο (δηλαδή η ακτίνα).

Μπορούμε να δημιουργήσουμε σημεία καρτεσιανής αναπαράστασης χρησιμοποιώντας το `Point.cartesian` και για την πολική αναπαράσταση μπορούμε να χρησιμοποιήσουμε το `Point.polar`. Στον παρακάτω πίνακα μπορείτε να δείτε τις βασικές μεθόδους του `Point`.

----------------------------------------------------------------------------------------------------------
Τελεστής                            Τύπος   Περιγραφή                     Παράδειγμα
----------------------------------- ------- ----------------------------  --------------------------------
`Point.cartesian(Double, Double)`   `Point` Κατασκευάζει ένα `Point`      `Point.cartesian(1.0, 1.0)`
                                            (σημείο) χρησιμοποιώντας
                                            καρτεσιανή αναπαράσταση

`Point.polar(Double, Angle)`        `Point` Κατασκευάζει ένα `Point`      `Point.polar(1.0, 90.degrees)`
`Point(Double, Angle)`                      χρησιμοποιώντας
                                            πολική αναπαράσταση

`Point.zero`                        `Point` Κατασκευάζει ένα `Point`       `Point.zero`
                                            όπου τα x και y είναι 0

`Point.x`                           `Double` Επιστρέφει την συντεταγμένη   `Point.zero.x`
                                             x του `Point`.

`Point.y`                           `Double` Επιστρέφει την συντεταγμένη   `Point.zero.y`
                                             y του `Point`.

`Point.r`                           `Double` Επιστρέφει την ακτίνα του     `Point.zero.r`
                                             `Point`.
                                             
`Point.angle`                       `Angle`  Επιστρέφει την γωνία του      `Point.zero.angle`
                                             `Point`.
-----------------------------------------------------------------------------------------------------------


## Ευέλικτη Διάταξη

Μπορούμε να τοποθετήσουμε μία εικόνα σ' ένα συγκεκριμένο σημείο;
Μέχρι τώρα ξέρουμε μόνο πώς διατάσσουμε εικόνες χρησιμοποιώντας τα `on`, `beside`, και `above`.
Για να πετύχουμε μεγαλύτερη ευελιξία στον τρόπο διάταξης, χρειαζόμαστε ακόμη ένα εργαλείο, την μέθοδο `at`.
Παρακάτω μπορείτε να δείτε ένα παράδειγμα σχεδιασμού κύκλων στις γωνίες ενός τετραγώνου.

```tut:silent:book
val dot = Image.circle(5).lineWidth(3).lineColor(Color.crimson)
val squareDots =
  dot.at(0, 0).
    on(dot.at(0, 100)).
    on(dot.at(100, 100)).
    on(dot.at(100, 0))
```

Ο παραπάνω κώδικας δημιουργεί την εικόνα [@fig:hof:square-dots].

![Χρήση της `at` για την τοποθέτηση τεσσάρων κουκκίδων στις γωνίες ενός τετραγώνου.](src/pages/hof/square-dots.pdf+svg){#fig:hof:square-dots}

Για να καταλάβετε πώς λειτουργεί το `at` και γιατί πρέπει να τοποθετήσουμε τις κουκκίδες τη μία πάνω στην άλλη χρησιμοποιώντας το `on`, πρέπει να ξέρουμε πώς χειρίζεται τις διατάξεις το Doodle.

Κάθε εικόνα στο Doodle έχει μία *αρχική θέση*.
Για τις περισσότερες περιπτώσεις η θέση αυτή βρίσκεται στο κέντρο, χωρίς αυτό να είναι πάντα απαραίτητο.
Όταν μία διάταξη του Doodle συνδυάζει εικόνες, τοποθετεί σε μία ευθεία γραμμή τις αρχικές τους θέσεις.
Για παράδειγμα, αν μερικές εικόνες έχουν διαταχθεί με την χρήση του `above` τότε οι αρχικές τους θέσεις βρίσκονται σε μία κάθετη ευθεία και η αρχική θέση της σύνθετης εικόνας βρίσκεται στην μέση της νοητής γραμμής που συνδέει τις αρχικές θέσεις των μεμονωμένων εικόνων.
Στην εικόνα [@fig:hof:horizontal-layout] μπορείτε να δείτε ένα παράδειγμα διάταξης με `beside` στο οποίο φαίνεται το πώς ευθυγραμμίζονται οι αρχικές θέσεις (οι κόκκινοι κύκλοι).
Τέλος, με το `on` οι αρχικές θέσεις τοποθετούνται η μία πάνω στην άλλη έτσι ώστε να μοιράζονται μία κοινή αρχική θέση.

![Ένα παράδειγμα οριζόντιας διάταξης (με χρήση του `beside`), στο οποίο φαίνεται πώς ευθυγραμμίζονται οι αρχικές θέσεις.](src/pages/hof/horizontal-layout.pdf+svg){#fig:hof:horizontal-layout}

Χρησιμοποιώντας το `at` μπορούμε να μετακινήσουμε μία εικόνα σε άλλη θέση από την αρχική της.
Στα παραδείγματα που ακολουθούν θέλουμε όλα τα στοιχεία της εικόνας να μοιράζονται μία κοινή αρχική θέση και γι' αυτό χρησιμοποιήσαμε το `on` ώστε να συνδυάσουμε εικόνες που έχουμε μετακινήσει χρησιμοποιώντας το `at`.

Υπάρχουν δύο τρόποι κλήσης του `at`:

 - περνώντας τις συντεταγμένες x και y, όπως για παράδειγμα `dot.at(100, 100)`, ή
 - περνώντας ένα `Vec` (διάνυσμα) το οποίο δίνει τις συντεταγμένες `dot.at(Vec(100, 100))`.
 
Μπορούμε να μετατρέψουμε ένα `Point` σε `Vec` χρησιμοποιώντας την μέθοδο `toVec`.

```tut:book
Point.cartesian(1.0, 1.0).toVec
```

## Γεωμετρία

Το τελευταίο στοιχείο που χρειάζεται να ξέρουμε για να τοποθετήσουμε τις εικόνες σε διάφορα σημεία, είναι λίγη γεωμετρία.
Αν ένα σημείο είναι τοποθετημένο σε απόσταση `r` από το αρχικό σημείο και σε γωνία `a`, οι συντεταγμένες x και y είναι `(a.cos) * r` και `(a.sin) * r` αντίστοιχα.
Εναλλακτικά μπορούμε απλώς να χρησιμοποιήσουμε πολικές συντεταγμένες!

```tut:book
val polar = Point.polar(1.0, 45.degrees)
val cartesian = Point.cartesian((45.degrees.cos) * 1.0, (45.degrees.sin) * 1.0)

// Είναι ίδια
polar.toCartesian == cartesian
cartesian.toPolar == polar
```


## Συνδυάζοντας

Μπορούμε να συνδιάσουμε τα παραπάνω, ώστε να δημιουργήσουμε έναν παραμετρικό κύκλο.
Ο κώδικας ενός παραμετρικού κύκλου με ακτίνα 200 σε καρτεσιανές συντεταγμένες είναι ο παρακάτω

```tut:silent:book
def parametricCircle(angle: Angle): Point =
  Point.cartesian(angle.cos * 200, angle.sin * 200)
```

Σε πολική μορφή είναι ο παρακάτω

```tut:silent:book
def parametricCircle(angle: Angle): Point =
  Point.polar(200, angle)
```

Μπορούμε ακόμη να διαλέξουμε ομοιόμορφα κατανεμημένα σημεία του κύκλου. Ζωγραφίζοντας κάτι σε κάθε σημείο μπορούμε να δημιουργήσουμε μία εικόνα (για παράδειγμα ένα τρίγωνο).

```tut:silent:book
def sample(start: Angle, samples: Int): Image = {
  // Το Angle.one είναι μια ολόκληρη περιστροφή. Δηλαδή 360 μοίρες
  val step = Angle.one / samples
  val dot = triangle(10, 10)
  def loop(count: Int): Image = {
    val angle = step * count
    count match {
      case 0 => Image.empty
      case n =>
        dot.at(parametricCircle(angle).toVec) on loop(n - 1)
    }
  }
  
  loop(samples)
}
```

Το παραπάνω είναι μία δομημένη αναδρομή που ελπίζουμε να σας φαίνεται αρκετά οικεία.

Αν το εκτελέσουμε, θα δούμε να σχηματίζεται ένας κύκλος με την βοήθεια τριγώνων.
Δείτε την εικόνα [@fig:hof:triangle-circle], στην οποία φαίνονται τα αποτελέσματα του `sample(0.degrees, 72)`.

![Τρίγωνα σε κύκλο που προέκυψαν από τον κώδικα `sample`.](src/pages/hof/triangle-circle.pdf+svg){#fig:hof:triangle-circle}

### Λουλούδια

Το επόμενο βήμα για την δημιουργία του λουλουδιού είναι η χρήση ενός πιο ενδιαφέροντος σχήματος από τον κύκλο. Αυτό σημαίνει ότι θα πρέπει να αλλάξουμε το `parametricCircle` σε μία πιο ενδιαφέρουσα εξίσωση.
Ίσως σαν την `rose` που μπορείτε να δείτε παρακάτω.
Αυτό είναι ένα παράδειγμα καμπύλης τριαντάφυλλου, με μέγιστη ακτίνα 200.
Μπορούμε να αλλάξουμε την τιμή που πολλαπλασιάζεται με την γωνία (στην συγκεκριμένη περίπτωση είναι 7) ώστε να πάρουμε ένα διαφορετικό σχήμα.

```tut:silent:book
// Παραμετρική εξίσωση για το τριαντάφυλλο με k = 7
def rose(angle: Angle) =
  Point.polar((angle * 7).cos * 200, angle)
```

Μπορείτε να δείτε ένα παράδειγμα στην εικόνα [@fig:hof:rose].

![Ένα παράδειγμα της καμπύλης του τριαντάφυλλου.](src/pages/hof/rose.pdf+svg){#fig:hof:rose}

Μπορούμε να αλλάξουμε την `sample` ώστε να καλεί την `rose` αντί για την `parametricCircle` αλλά και πάλι το αποτέλεσμα δεν θα είναι ικανοποιητικό.
Ας πειραματιστούμε με διαφορετικές παραμετρικές εξισώσεις!
Θα ήταν πολύ βολικό αν μπορούσαμε να περάσουμε ως παράμετρο στην `sample` την μέθοδο που δημιουργεί σημεία (δηλαδή την παραμετρική εξίσωση).
Μπορούμε όμως να κάνουμε κάτι τέτοιο;
Για να το κάνουμε πρέπει:

- να γράψουμε τον τύπο μίας μεθόδου
- να διαχωρίσουμε την κλήση μίας μεθόδου (πχ την `rose(0.degrees)`) από την μέθοδο καθαυτήν.

Ας δούμε το δεύτερο πρόβλημα. Αν προσπαθήσουμε να αναφερθούμε σε μία μέθοδο χωρίς να την καλέσουμε θα λάβουμε ένα μήνυμα λάθους.

```tut:fail:book
rose
```

Το μήνυμα λάθους μας λέει από μόνο του τι πρέπει να διορθώσουμε και αυτό είναι ένα πολύ καλό σημείο για να εισάγουμε επιτέλους τις συναρτήσεις.
